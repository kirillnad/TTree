# ТЗ: Outline-редактор на TipTap (секции по заголовкам)

## Цель

Сделать редактирование статьи как одного документа TipTap, где структура (дерево) **рождается из заголовков** и выглядит для пользователя как “структурированный текст”.

Каждая секция (заголовок + тело + дети) — **единица смысла**:
- используется как отдельный “блок” для поиска и embeddings;
- имеет устойчивый `id`;
- поддерживает сворачивание/разворачивание;
- поддерживает перемещение среди sibling’ов и смену уровня вложенности.

## Термины

- **Документ** — TipTap/ProseMirror `doc` для всей статьи.
- **Блок** — единица смысла в Memus: `heading + body + children` + `collapsed` + устойчивый `id`.
- **Секция (`section`)** — нода TipTap/ProseMirror, реализующая “блок” в документе (внутренний технический термин).
- **Единица смысла** — то, что индексируется и эмбеддится (равно секции).
- **Тело секции (`body`)** — контент секции, **не включая** дочерние секции.

## Принципы и ключевые решения

1. **Секции только с заголовками**  
   Секции без заголовков не допускаются (они визуально путают уровни).  
   “Intro” не является отдельной беззаголовочной секцией: роль intro выполняет **название статьи** (UI вне документа).

2. **Embeddings/поиск: только title + body (без детей)**  
   Для секции `S`: текст для индекса/эмбеддинга = `plain(title(S)) + "\n" + plain(body(S))`, **без** текстов дочерних секций.
   Источник истины для текста секции — только `articles.article_doc_json` (outlineSection → heading/body). Legacy `blocks`/`blocks_fts` не используются в runtime (только как исторический артефакт/одноразовая миграция).

3. **Структура хранится явно, не эвристикой**  
   В документе должна существовать явная нода `section` (а не “угадывание секций” по голым `heading/paragraph`).
   Это снижает риск “потеряться” после сложных операций (split/merge/move/paste).

3.1. **Уникальные идентификаторы секций**  
   Для `outlineSection` используется `UniqueID` (TipTap) для:
   - генерации `id` для новых секций;
   - автоматической замены `id` при paste/drag-copy (чтобы не появлялись дубликаты).

4. **Глобальный undo по статье + история по секции**  
   - Undo/redo по статье — стандартный ProseMirror `history`.
   - “История изменений именно секции” — хранится как ревизии на сохранении (см. раздел “История секций”).
   - “Сохранение секции” как UX-событие: ревизия секции фиксируется естественно при уходе курсора из секции (не отдельной кнопкой).

5. **Статья не требует явного сохранения**  
   Пользователь не должен нажимать “Сохранить/Отменить”.  
   Текст сохраняется автоматически, а “Версии” — отдельный механизм (см. ниже).

6. **TipTap грузится локально (без CDN)**  
   TipTap/ProseMirror расширения собираются в `TTree/client/outline/tiptap.bundle.js` (esbuild) и импортируются локально из `TTree/client/outline/editor.js`.
   Пересборка: `cd TTree && npm run build:tiptap`.

## UX: как это выглядит для пользователя

- Визуальная тема приложения — “Professional Slate”: единый акцент `--primary=#007ACC`, светлый фон контента `--bg-app=#f8fafc`, тёмный сайдбар на Slate (`--sidebar-bg=#0f172a`). Источник истины — CSS-переменные в `TTree/client/style.css`.
- В сайдбаре используется **одно поле** вместо двух:
  - режим **“Список”** — ввод фильтрует дерево/список статей локально (быстро, без сервера);
  - режим **“Поиск”** — ввод запускает глобальный поиск по содержимому (и показывает результаты под полем);
  - переключатель “Список/Поиск” расположен рядом с полем; `Ai`‑переключатель показывается только в режиме “Поиск”.
- Статья выглядит как структурированный текст с заголовками.
- У каждого заголовка есть контроль сворачивания/разворачивания содержимого секции (тело + дочерние секции).
- Пользователь создаёт структуру естественно: **заголовок = новая секция**.
- Внутри секции `Enter` создаёт новые абзацы **в теле**, не “новый блок”.
- В режиме outline стандартный `articleToolbar` (блочный тулбар) скрыт; на его месте показывается `outlineToolbar` с командами TipTap.
  В режиме просмотра `outlineToolbar` показывает Undo/Redo и быстрые кнопки: удалить блок (в корзину), переместить ↑/↓, сдвиг ←/→, новый блок ниже. В режиме редактирования команды сгруппированы по выпадающим меню: “Текст”, “Списки”, “Таблица” (Undo/Redo остаются отдельными кнопками).
- Двойной клик по заголовку секции в режиме просмотра: раскрывает секцию (если была свёрнута), включает режим редактирования и ставит курсор в начало тела секции.
- Статус outliner’а (“Сохраняем…”, “Сохранено …”) показывается в UI вместо `updatedAt` (в меню статьи), отдельная панель `.outline-editor__bar` не используется.
  - Вставка URL-ссылки: в одном диалоге запрашиваются и URL, и текст ссылки (текст можно оставить пустым; если было выделение — оно подставляется как текст).

## Удаление старого блочного режима (HTML blocks)

- Старый режим редактирования через `blocks.text` (HTML) выключен.
- Интерфейс статьи всегда открывается в outline‑режиме (TipTap): чтение + вход в edit‑mode по Enter/F2/dblclick.
- `blocks`/`blocks_fts` больше не являются частью схемы хранения статьи: API не читает и не пишет их. Эмбеддинги/поиск строятся по `section_id` из `article_doc_json`.
  - `article_links` пересчитывается из `article_doc_json` (link mark href `/article/<id>`) при сохранении outline;
  - FTS по содержимому работает через `outline_sections_fts`;
  - semantic embeddings хранятся в `block_embeddings`, где `block_id == section_id`.
  Для таблиц используем `TableKit` из `@tiptap/extension-table` (resizable columns) и команды: вставка таблицы 2×2, add/delete row/column (до/после), toggle header row/column, merge/split cell (если применимо), **“отменить таблицу” → преобразовать таблицу в обычный текст** (каждая ячейка становится отдельным абзацем).

## Markdown
- Официальный `@tiptap/extension-markdown` в публичном npm недоступен, используем community-пакет `tiptap-markdown` (Tiptap v3).
- Extension `Markdown` подключён в outline editor (пока без auto-transform paste).
- Команда: `editor.commands.insertMarkdown(markdown)` — конвертирует Markdown → HTML (через `editor.storage.markdown.parser`) и вставляет в текущую позицию курсора (только в edit-mode).
- Markdown-таблицы вида:
  - `| A | B |`
  - `|---|---|`
  - `| 1 | 2 |`
  при вставке (Ctrl+V) автоматически превращаются в настоящую таблицу.
- Также поддерживается “упрощённый” вариант без строки-разделителя `|---|---|`: если вставлены 1+ строк вида `| ... |` с одинаковым числом столбцов, они превращаются в таблицу без header.
- Если в существующем контенте/`doc_json` есть такая таблица текстом, при открытии outline и/или при входе в редактирование секции она мигрируется в таблицу.
  В меню “Текст”:
  - “Код” — это именно `codeBlock` (многострочный блок кода); legacy-вставки вида `<code>...<br>...</code>` автоматически мигрируются в `codeBlock` при входе в редактирование секции.
  - доступны действия со ссылками: вставка URL, вставка ссылки на статью (как в rich-context-menu старого режима) и “убрать ссылку”.

### Режимы: просмотр / редактирование

Чтобы снизить риск случайных правок:
- По умолчанию секции находятся в режиме **просмотра**: можно перемещать курсор, выделять и копировать текст, но любые изменения документа (ввод, удаление, вставка, drag&drop) блокируются.
- `Enter` или `F2` включает режим **редактирования** для текущей секции (редактируются только её `heading` и `body`, без детей).
- `dblclick` по секции также включает режим редактирования для этой секции.
- `Esc` — выход из режима редактирования обратно в просмотр.
- При уходе курсора в другую секцию режим редактирования автоматически выключается.
- При выходе из режима редактирования (`Esc`) автозаголовок и proofreading запускаются так же, как при “уходе” в другую секцию (если заголовок пустой / были изменения).
- Undo/Redo должны работать в обоих режимах (view/edit), т.к. это безопасная обратимая операция.
- В режиме просмотра клики по ссылкам должны открывать их (вкладка/переход), в режиме редактирования клик работает как обычная установка курсора.
- Склейка секций через `Backspace` на границе (в начале заголовка) доступна **только в режиме редактирования** и защищена от “зажатой клавиши”:
  - первое нажатие (`repeat=false`) — только тост “Нажмите ещё раз, чтобы объединить блоки”, без склейки;
  - второе нажатие в течение ~1.2 секунды — выполняет склейку;
  - автоповтор (`repeat=true`) игнорируется и склейку не запускает.
  - аналогично для `Delete` на границе (в конце `body`) при объединении с нижним sibling.
  - при склейке заголовок “нижней” секции не теряется: он переносится в `body` секции-приёмника отдельным абзацем, затем добавляется `body`.

## Сохранение (автосейв)

### Принцип

- Сохранение статьи происходит **автоматически** (debounce) и не требует действий пользователя.
- Единственная “явная” сущность, которую пользователь может сохранять руками — это **Версия** (snapshot).

### Триггеры автосейва

- Любое изменение документа: debounce ~1–2 секунды.
- Уход со статьи / переключение на другую статью / `blur` окна: форс-флаш очереди (без диалогов).

### Гарантии при сбоях

- Если сеть/сервер недоступны: изменения складываются в локальную очередь и будут отправлены позже (без диалогов “сохранить?”).
- Автосейв никогда не “пропадает”: либо он ушёл на сервер, либо лежит локально и ждёт синка.

### UI (минимально)

- Нет кнопок “Сохранить” и “Отменить” в редакторе статьи.
- Можно показывать неблокирующий статус: “Сохраняется… / Сохранено / Ошибка, повторим”.

## Offline-first (always-on) на IndexedDB

### Цель

Сделать офлайн-режим **не опциональным**: приложение всегда работает как offline-first, а сервер используется для синхронизации, эмбеддингов и публичных функций.

### Ключевой принцип

Локальная база (IndexedDB) — это **рабочее состояние** приложения. Сервер — “источник истины” и синк, но UI не должен зависеть от наличия сети.

### Варианты синхронизации (старый/новый)

В этом документе фиксируются 2 варианта:

- **Вариант A (старый, текущий в коде на момент написания)** — смешанный: часть изменений отправляется direct, часть через outbox, плюс отдельные правила для структуры (debounce/throttle).
- **Вариант B (новый, целевой)** — outbox‑only: UI всегда пишет локально, а на сервер изменения уходят только фоном из очереди.

### Вариант B (новый): outbox‑only синхронизация (целевая схема)

ТЗ (строго): отказаться от “отправить сразу” и от смешанного direct/outbox.

Вариант B определяет следующие правила:
- Любое изменение пользователя **сразу** применяется в UI.
- Любое изменение пользователя фиксируется локально в IndexedDB **в момент редактирования** (при успешной записи).
  - Ограничение iOS: IndexedDB — кэш, который может быть эвикчен ОС **после** успешной записи (см. “Ограничения iOS” ниже). Поэтому локальная фиксация не является долговременной гарантией; долговременная гарантия появляется только после синка на сервер.
- Любое изменение пользователя **на сервер** попадает только через outbox (фоновая синхронизация). Direct‑запросов из outline‑автосейва нет.

#### B0. Инварианты UI

- Если outbox пуст — UI статуса синхронизации **не показывает ничего**.
- Если outbox не пуст — UI показывает “Изменения не на сервере” + причину, если синк не идёт:
  - offline → “Нет интернета”,
  - 401/403 → “Нужна авторизация”,
  - 5xx/timeout → “Сервер недоступен”.

Инвариант конфликтов контента (строго):
- Если сервер вернул `UpsertAck.result:"conflict"`, outbox при этом может стать пустым.
- В этом случае UI обязан:
  1) создать конфликтную копию блока (см. B9),
  2) показать toast “Конфликт: создана копия блока”.

#### B1. Что считается “изменением” (dirty detection)

Требование: секция помечается “грязной” **только если она реально изменилась**, а не из‑за навигации курсора.

Строго:
- Для каждой секции `sectionId` хранится локальный “слепок” `lastCommittedHash`.
- При изменениях документа для каждой затронутой секции вычисляется `currentHash = hash(headingJson, bodyJson)`.
- `dirtySectionIds.add(sectionId)` выполняется только если `currentHash !== lastCommittedHash` для этой секции.
- При local commit слепок обновляется: `lastCommittedHash = currentHash`.

#### B1.1. Pull-контракт статьи (строго)

Требование: при открытии статьи клиент делает pull с сервера и получает как `docJson`, так и метаданные ревизий.

Endpoint (строго):
- `GET /api/articles/{articleId}`

Response (строго):
- `{ status:"ok", articleId, updatedAt, docJson, structureRev, sectionsMeta }`, где:
  - `structureRev: number` — текущая ревизия структуры статьи,
  - `sectionsMeta: { [sectionId: string]: { contentRev: number, deleted: boolean } }`

Клиент хранит `structureRev` и `contentRev` отдельно от `docJson` (метаданные IndexedDB).

#### B1.2. Откуда берутся `baseContentRev` и `baseStructureRev` (строго)

Источник `contentRev` по секциям:
1) pull статьи с сервера (при открытии статьи) — сервер возвращает текущие `contentRev` по секциям,
2) push `sync/compact` — сервер возвращает `upserts[].newContentRev` (для `result:"applied"`/`result:"duplicate"`), клиент обновляет локальные ревизии только по этим подтверждениям.

Источник `structureRev` по статье:
1) pull статьи с сервера (при открытии статьи) — сервер возвращает текущий `structureRev`,
2) push `structure/snapshot` — сервер возвращает `newStructureRev`, клиент обновляет локальную ревизию только по этому подтверждению.

#### B1.3. Как определить “затронутые секции” (строго)

Запрещено помечать dirty “только текущую секцию”: paste/split/merge и некоторые команды могут изменить несколько секций одной транзакцией.

Определение `touchedSectionIds` для одной ProseMirror‑транзакции `tr`:
1) собрать список диапазонов изменений из `tr.mapping.maps`:
   - для каждого `StepMap` вызвать `forEach((oldStart, oldEnd, newStart, newEnd) => ...)` и добавить диапазоны `old` и `new`,
2) для каждого диапазона:
   - найти все `outlineSection` (по `attrs.id`), которые пересекают диапазон:
     - в документе **до** транзакции (`prevState.doc`), используя `oldStart..oldEnd`,
     - в документе **после** транзакции (`nextState.doc`), используя `newStart..newEnd`,
3) объединить ids в множество `touchedSectionIds`.

После вычисления `touchedSectionIds`:
- для каждого `sectionId` пересчитать `currentHash` и сравнить с `lastCommittedHash`;
- если секция новая (слепка нет) → считать dirty;
- если секция была удалена → `sectionId` должен попасть в `delete_sections` (это отдельная логика и не через hash).

Fallback (строго):
- если по какой‑то причине нельзя надёжно вычислить `touchedSectionIds` для транзакции (например, неизвестная команда/нестандартная трансформация), то считаем затронутыми **все секции статьи** и сравниваем hash для всех секций (это дороже, но корректно).

#### B2. Local commit (единственная точка генерации ops)

Триггеры:
- debounce автосейва (после паузы в редактировании),
- уход/переключение статьи (не ждём сеть/сервер).

Действия local commit (строго, в таком порядке):
1) сохранить актуальный `docJson` статьи в IndexedDB (рабочее состояние),
2) сформировать outbox ops из dirty‑состояния (см. B3),
3) очистить dirty‑флаги и обновить слепки.

#### B3. Типы ops (outline) и содержимое

Outbox хранит операции, каждая имеет стабильный `opId` (UUID) и `articleId`.

- `delete_sections`
  - payload: `{ opId, articleId, sectionIds[] }`
- `section_upsert_content`
  - payload: `{ opId, articleId, sectionId, headingJson, bodyJson, baseContentRev, clientEditedAtUtc }`
  - `baseContentRev` — целое число или `null`:
    - `null` → клиент считает секцию “новой” (на сервере ещё нет контента/меты),
    - число → это `contentRev`, который клиент получил с сервера последним “подтверждённым” (см. B6/B7).
  - `clientEditedAtUtc` — ISO‑строка времени (UTC) **только для диагностики/аудита**, не участвует в разрешении конфликтов.
- `structure_snapshot`
  - payload: `{ opId, articleId, baseStructureRev, nodes[] }`, где:
    - `baseStructureRev` — целое число (последний подтверждённый `structureRev`, который клиент получил с сервера),
    - `nodes[] = { sectionId, parentId|null, position:number, collapsed:boolean }`

#### B3.1. Нормализация и coalesce (строго)

Локальная очередь хранит **только итоговое состояние**, а не “все мелкие шаги”.

Состояние операции (строго):
- `pending` — лежит в outbox и ещё не отправлялась,
- `in_flight` — отправлена и ожидается ответ,

Правило хранения (строго):
- в IndexedDB/outbox хранятся только операции в состоянии `pending`;
- `in_flight` — только in-memory и сбрасывается при перезагрузке страницы (операции снова считаются `pending`).

Правила coalesce (строго):
- `delete_sections` coalesce по ключу `delete:{articleId}`:
  - в outbox может быть:
    - не более одной `delete_sections` в состоянии `in_flight` (immutable),
    - не более одной `delete_sections` в состоянии `pending` (последнее состояние);
  - `sectionIds[]` — массив уникальных `sectionId` (без дублей), пополняется при следующих local commit;
  - coalesce применяется только если операция `pending`;
  - при замене операции создаётся **новый** `opId`, старая операция удаляется из outbox.
- `section_upsert_content` coalesce по ключу `upsert:{articleId}:{sectionId}`:
  - в outbox может быть:
    - не более одного `section_upsert_content` для этой секции в состоянии `in_flight` (immutable),
    - не более одного `section_upsert_content` для этой секции в состоянии `pending` (последнее состояние);
  - новый `pending` upsert **заменяет** старый `pending` upsert (в очереди всегда “последнее состояние секции”);
  - coalesce применяется только если операция `pending`;
  - при замене операции создаётся **новый** `opId`, старая операция удаляется из outbox.
- `structure_snapshot` coalesce по ключу `structure:{articleId}`:
  - в outbox может быть:
    - не более одного `structure_snapshot` в состоянии `in_flight` (immutable),
    - не более одного `structure_snapshot` в состоянии `pending` (последняя структура);
  - новый `pending` snapshot **заменяет** старый `pending` snapshot (в очереди всегда “последняя структура”);
  - coalesce применяется только если операция `pending`;
  - при замене операции создаётся **новый** `opId`, старая операция удаляется из outbox.

Правило “delete побеждает” (строго):
- если `sectionId` попадает в `delete_sections.sectionIds`, то:
  - любые `section_upsert_content` для этого `sectionId` **удаляются** из outbox;
  - в `sync/compact` эта секция попадает только в `deletes` (и никогда в `upserts`).

#### B4. Порядок всегда один: delete → upsert → structure

Это строгий порядок применения изменений на сервере и строгий порядок отправки.

Причина:
- delete должен “выигрывать” у upsert (иначе upsert может создать удалённую секцию заново),
- структура применяется последней: после удаления/создания/обновления секций.

#### B5. Фоновая синхронизация (автоматически)

Таймер: каждые **15 секунд**, пока outbox не пуст.

Триггеры немедленного запуска: событие `online`.

Правило: синк всегда автоматический; кнопки “Синхронизировать сейчас” нет.

В варианте B синхронизация outline на сервер выполняется **только двумя** HTTP‑запросами:
- `update` (delete+upsert): `PUT /api/articles/{articleId}/sync/compact` (см. B6),
- `structure` (структура): `PUT /api/articles/{articleId}/structure/snapshot` (см. B7).

Важно (строго):
- `update` отправляет **всё**, что есть в outbox на момент flush для `delete_sections` и `section_upsert_content` этой статьи (после coalesce, см. B3.1).
- `structure` отправляет **последний** `structure_snapshot` этой статьи (после coalesce, см. B3.1).

Алгоритм синка для одной статьи (строго, порядок неизменен):
1) собрать из outbox для `articleId` все ops `delete_sections` и `section_upsert_content`,
2) если в этом наборе есть хоть одна операция:
   - пометить ops, вошедшие в запрос, как `in_flight`,
   - отправить их одним запросом (см. B6 “compact”),
    - если ответ `{status:"ok"}` получен:
      - применить ack к локальным метаданным:
        - для каждого `UpsertAck`:
          - если `result:"applied"` или `result:"duplicate"` → установить `sectionsMeta[sectionId].contentRev = newContentRev` и `sectionsMeta[sectionId].conflicted=false`,
          - если `result:"conflict"` → установить `sectionsMeta[sectionId].contentRev = currentContentRev`,
        - для каждого `DeleteAck` с `result:"applied"` или `result:"duplicate"`:
          - для каждого `sectionId` из `DeleteAck.removedBlockIds` локально пометить `sectionsMeta[sectionId].deleted=true` (tombstone),
      - удалить из outbox:
        - все `delete_sections`, которые вошли в пакет,
        - все `section_upsert_content`, чей `opId` получил ack в ответе (applied/duplicate/conflict) (см. B6),
      - для всех оставшихся ops этого запроса убрать `in_flight` (они снова `pending`),
   - если ответ не получен/ошибка — убрать `in_flight` у ops этого запроса (они снова `pending`) и закончить попытку (outbox остаётся, будет повтор),
3) затем, если `update` завершился успехом и в outbox есть `structure_snapshot` для этой статьи — отправить его вторым запросом,
4) если получен `{ status:"ok" }` — удалить `structure_snapshot` из outbox и обновить локальный `structureRev = newStructureRev`,
5) если получен `{ status:"ignored" }` — удалить `structure_snapshot` из outbox и обновить локальный `structureRev = currentStructureRev` (структура на сервере уже новее).

#### B5.1. Экстренная доставка при уходе (мобайл/PWA)

Проблема: на мобильных ОС при уходе приложения в фон/закрытии вкладки фоновая синхронизация может не успеть.

Триггеры (строго):
- `visibilitychange` → `document.visibilityState === "hidden"`,
- `pagehide`.

Алгоритм (строго):
1) выполнить local commit (B2) для текущей статьи, **не ожидая сети**,
2) сделать best‑effort попытку отправить “всё delete+upsert” этой статьи через `sync/compact` (обычный `fetch`, **без** `keepalive`):
   - если клиент успел получить ответ `{status:"ok"}` — применить ack и очистить outbox как в B5,
3) если шаг (2) завершился успехом и в outbox есть `structure_snapshot` — сделать best‑effort попытку отправить его вторым запросом,
4) если вкладка/приложение выгружены раньше, чем пришёл ответ (запрос прерван/ответ потерян) — ничего больше не делаем; при следующем запуске outbox отправится обычным фоном (B5), а повторная отправка безопасна из‑за ack replay по `opId` (B8).

Ограничение (строго):
- экстренная отправка может постоянно падать по timeout/ошибкам, если payload очень большой (например, огромный paste в одну секцию).
- В этом случае клиент действует как при TTL‑просрочке (B8): показывает “нужен pull для синхронизации” и не крутит бесконечные ретраи в фоне.

#### B5.4. Триггеры flush (строго)

Операции (`delete_sections` / `section_upsert_content` / `structure_snapshot`) кладутся в outbox **сразу при изменении** (local commit фиксирует `docJson` и формирует ops), но отправка на сервер выполняется только в следующих случаях:

1) Выход из edit‑mode секции, если секция реально изменилась (dirty по B1/B1.3) → запускаем flush.
2) Удаление секции → запускаем flush.
3) Изменение структуры → запланировать flush через 3000ms после последнего структурного изменения.
4) Таймер бездействия (idle) 3000ms: если пользователь не делает действий и outbox не пуст → запускаем flush.
5) Safety‑timer 15000ms: если outbox не пуст → запускаем flush (для “очистки совести”).

#### B5.5. Частота и блокировка flush (строго)

Правила:
- flush для одной статьи не стартует чаще, чем 1 раз в 3000ms (между стартами).
- пока выполняется flush (есть `in_flight` ops этой статьи), новые изменения продолжают попадать в outbox и coalesce’ятся; следующий flush стартует после завершения текущего и соблюдения лимита 3000ms.

#### B5.6. Лимит размера секции (строго)

Техническое ограничение: нельзя “сохранять блок” (выходить из edit‑mode), если размер секции превышает лимит.

Определение размера (строго):
- `sectionPayloadBytes = utf8Bytes(JSON.stringify({ headingJson, bodyJson }))`

Лимит (строго):
- `MAX_SECTION_BYTES = 262144` (256 KiB) на одну секцию.

Поведение клиента (строго):
- при попытке выхода из edit‑mode:
  - если `sectionPayloadBytes > MAX_SECTION_BYTES`:
    1) выход из edit‑mode отменяется (остаёмся в редактировании),
    2) показывается сообщение: “Блок слишком большой для сохранения. Разбейте текст на несколько блоков.”,
    3) flush не запускается.

Важно (строго):
- лимит `MAX_SECTION_BYTES` не должен блокировать удаление: удаление секции разрешено всегда (delete может быть единственным способом “выйти” из проблемного состояния).

Поведение сервера (строго, страховка):
- если клиент всё же отправил oversized payload, сервер возвращает 413 и **не применяет** изменения.

#### B5.2. Поведение при ошибках и backoff (строго)

Если outbox не пуст и синк не проходит, действует следующий алгоритм:
- `offline` (нет сети): не отправлять запросы; ждать события `online`.
- `401/403`: не отправлять запросы; ждать успешной авторизации (следующий удачный API‑запрос с 200 сбрасывает стоп‑флаг).
- `5xx/timeout/сетевые ошибки`: экспоненциальный backoff на статью:
  - задержки: 1s → 2s → 4s → 8s → 15s → 30s → 60s (cap 60s),
  - при любом успешном ответе backoff сбрасывается в 0.

#### B5.3. Outbox по нескольким статьям (строго)

Тик синхронизации обрабатывает несколько статей по очереди.

Правила (строго):
- одновременно может выполняться не более одного `flush(articleId)` (mutex на статью);
- на каждом тике выбираются статьи с непустым outbox в round‑robin порядке по ключу `leastRecentlyFlushedAt`;
- за один тик обрабатывается не более 3 статей, остальные ждут следующий тик.

Примечание (строго):
- `leastRecentlyFlushedAt` хранится только in-memory; после перезагрузки порядок round‑robin начинается заново.

#### B6. Compact endpoint (delete+upsert одним запросом)

Для единообразия и для уменьшения числа запросов вводится batch‑endpoint:

- `PUT /api/articles/{articleId}/sync/compact`
  - request body:
    - `deletes`: список `{ opId, sectionIds[] }` (из‑за B3.1: либо пусто, либо ровно 1 элемент; формат допускает несколько),
    - `upserts`: список `{ opId, sectionId, headingJson, bodyJson, baseContentRev, clientEditedAtUtc }` (по одной записи на секцию; “последнее состояние секции”).
  - сервер применяет в одной транзакции (и под `SELECT ... FOR UPDATE`) строго в порядке:
    1) delete_sections,
    2) section_upsert_content.
  - response:
    - `{ status:"ok", articleId, updatedAt, deletes: DeleteAck[], upserts: UpsertAck[] }`
      - `DeleteAck = { opId, result: "applied" | "duplicate", removedBlockIds: string[] }`
      - `UpsertAck = { opId, sectionId, result: "applied" | "duplicate" | "conflict", reason?: "rev_mismatch" | "deleted_tombstone" | "id_collision", newContentRev?: number, currentContentRev?: number }`
      - `result:"duplicate"` означает: сервер уже применял этот `opId` ранее и возвращает **тот же ack**, что и в первый раз (см. B8).
      - `result:"conflict"` означает: `baseContentRev` не совпал с текущим `contentRev` на сервере; контент **не применяется** (см. B9).

Delete semantics (строго):
- сервер хранит мету секции `(articleId, sectionId)` с полями `contentRev` и `deleted` (tombstone), вне `docJson`;
- при delete:
  - секция удаляется из `article_doc_json`,
  - `removedBlockIds` включает все реально удалённые секции (включая дочерние, если удаление рекурсивное),
  - мета обновляется: `deleted=true`, `contentRev = contentRev + 1` (если меты нет — создаётся с `contentRev=1`),
  - повторный delete той же секции допустим и считается no-op (но ack replay по `opId` обязателен).
- при upsert:
  - если `deleted=true` на сервере → `result:"conflict"` (воскрешение запрещено; нужно создать новую секцию с новым `sectionId`).

Derived обновления на сервере при `sync/compact`:
- Delete: удаление derived‑данных только для `DeleteAck.removedBlockIds`.
- Upsert: пересчёт derived‑данных только для `UpsertAck`, где `result:"applied"`:
  - FTS: пересчёт только для этих `sectionId`,
  - Embeddings: пересчёт только для этих `sectionId`,
  - Internal links: обновление только для этих `sectionId`,
    - правило: для `sectionId` сервер делает “delete all outgoing links for sectionId → insert new outgoing links for sectionId”.

Примечание (строго): `result:"duplicate"` не запускает пересчёт derived‑данных, потому что это повтор запроса и сервер ничего не применяет повторно (B8).

#### B7. Структура отдельным запросом

Второй запрос для структуры:
- `PUT /api/articles/{articleId}/structure/snapshot`
  - request body: `{ opId, baseStructureRev, nodes[] }`
  - response:
    - успех: `{ status:"ok", articleId, updatedAt, newStructureRev }`
    - stale: `{ status:"ignored", reason:"stale_structure", articleId, currentStructureRev }`
    - дубликат `opId`: сервер возвращает **тот же response**, что и в первый раз для этого `opId` (ack replay, B8).

Сервер при структуре:
- применяет только `{parentId, position, collapsed}` и не меняет контент секций.

#### B8. Повторы (повторная отправка) — как это работает

Повторная отправка возможна в двух случаях:
1) клиент отправил запрос, но не получил ответ (закрытие PWA, обрыв сети),
2) outbox делает ретраи при ошибках.

Требование для безопасности повторов (строго):
- сервер хранит таблицу “применённых opId” и для каждого opId делает дедуп + повтор ответа (ack replay):
  - если opId уже применён → сервер не применяет изменения повторно и возвращает **тот же результат**, что был в первый раз для этого opId.
- для `section_upsert_content` дополнительно действует `baseContentRev`:
  - если `baseContentRev` не совпал с текущим `contentRev` на сервере → сервер не применяет контент и возвращает `UpsertAck.result:"conflict"` (см. B9).

Следствие: если клиент не получил ответ и отправил повторно те же ops, сервер их не применит повторно.

GC для ack replay (строго):
- сервер хранит записи применённых `opId` ограниченное время (TTL), например 30 дней;
- после TTL сервер может удалять эти записи, и старые повторы `opId` перестают быть идемпотентными (это допустимо, т.к. повторы релевантны только в коротком окне после потери ответа).

Клиент и TTL (строго):
- каждая операция в outbox хранит `createdAtUtc` (UTC timestamp);
- если `nowUtc - createdAtUtc > TTL`, клиент:
  1) прекращает пытаться отправлять эту операцию,
  2) помечает статью как “нужен pull для синхронизации”,
  3) после pull пересоздаёт ops через local commit (создаёт новые `opId`).

#### B9. Конфликты с другим устройством (строго)

Конфликты возможны, если та же статья редактируется с другого устройства, пока это устройство оффлайн.

Вариант B запрещает “тихое” перетирание правок между устройствами.

Правило для контента секции (строго):
- сервер хранит `contentRev` для каждой секции (отдельная мета‑таблица, не в `docJson`);
- каждый upsert обязан нести `baseContentRev`;
- сервер применяет upsert **только если**:
  - секция уже существует → `baseContentRev === current contentRev`,
  - секции нет на сервере → `baseContentRev === null`;
- если `baseContentRev` не совпал:
  1) сервер **не применяет** контент,
  2) сервер определяет причину и возвращает её в `UpsertAck.reason`:
     - `rev_mismatch` — на сервере уже есть более новая версия секции,
     - `deleted_tombstone` — секция удалена (tombstone),
     - `id_collision` — `baseContentRev=null`, но `sectionId` уже существует на сервере,
  3) клиент создаёт конфликтную копию блока и сохраняет её как новую секцию (см. ниже).

Конфликтная копия (строго):
- `rev_mismatch`:
  1) клиент генерирует новый `sectionIdNew`,
  2) создаёт новый sibling‑блок **сразу после** конфликтной секции (в том же parent),
  3) контент новой секции = тот `headingJson/bodyJson`, который клиент пытался отправить,
  4) заголовок новой секции получает префикс: `Конфликтная копия: `,
  5) новая секция помечается атрибутом `isConflictCopy=true` (для подсветки в UI),
  6) для `sectionIdNew` формируется обычный `section_upsert_content` (с `baseContentRev=null`) и уходит на сервер в следующем flush,
  7) оригинальная конфликтная операция удаляется из outbox; UI показывает toast “Конфликт: создана копия блока”.
- `deleted_tombstone`:
  - создаём конфликтную копию как новый root‑блок в конце статьи (parentId=null, position=end), с тем же префиксом и `isConflictCopy=true`.
- `id_collision`:
  - трактуем как `rev_mismatch` и создаём конфликтную копию с новым `sectionIdNew`.

Точка создания копии (строго):
- конфликтная копия создаётся на клиенте немедленно (в `docJson` текущей статьи) при получении `UpsertAck.result:"conflict"`, без ожидания следующего редактирования.
- после вставки копии клиент обязан:
  1) пометить структуру dirty,
  2) положить `structure_snapshot` в outbox (coalesce),
  3) положить `section_upsert_content` для `sectionIdNew` в outbox,
  4) запустить flush по правилам B5.4/B5.5.

Ограничение (строго):
- если payload конфликтной копии превышает `MAX_SECTION_BYTES`, копия не создаётся:
  - показывается сообщение: “Блок слишком большой. Разбейте текст на несколько блоков.”,
  - пользователь остаётся в edit‑mode.

Ревизии контента (строго):
- при успешном применении upsert сервер увеличивает `contentRev` этой секции на 1 и возвращает это значение в `UpsertAck.newContentRev`.

Правило для структуры статьи (строго):
- сервер хранит `structureRev` для статьи (отдельная мета‑таблица/поле, не в `docJson`);
- snapshot применяется только если `baseStructureRev === current structureRev`;
- если `baseStructureRev` не совпал:
  - сервер **не применяет** структуру и возвращает `{ status:"ignored", reason:"stale_structure", currentStructureRev }`;
  - клиент удаляет op из outbox (другой клиент уже записал более новую структуру).

### Ограничения iOS (важно)

iOS Safari/WKWebView может **автоматически очищать** IndexedDB/кэш при нехватке места или по своим политикам. Это означает:
- локальная база на iOS должна считаться кэшем, который может быть эвикчен;
- приложение обязано уметь **самовосстанавливаться** (full pull) и продолжать работу.

### Стратегия “самовосстановления” (eviction-safe)

- При старте: если IndexedDB отсутствует/пустая/повреждена → показываем статус “Восстанавливаем локальные данные…” и выполняем **полную синхронизацию** с сервера (full pull).
- После full pull пересобираем локальные derived-данные (например, `sections`/FTS/кэши).
- Где возможно, вызываем `navigator.storage.persist()` (не гарантия, но снижает риск эвикшена).

### Вариант B: открытые вопросы и ограничения (фиксируем явно)

Открытых вопросов по Variant B больше нет; ниже перечислены принятые ограничения (это ожидаемое поведение).

1) Delete — разрушительная операция между устройствами:
   - delete всегда применяется и ставит tombstone;
   - если другое устройство успело отредактировать секцию, delete всё равно удалит её.

2) Структура — “stale → ignored”:
   - если два клиента меняли структуру, более старый snapshot будет проигнорирован;
   - локальная структура клиента может отличаться от серверной до следующего pull.

3) Ограничение размера секции:
   - действует `MAX_SECTION_BYTES`; oversized блок нельзя “сохранить” (выход из edit‑mode запрещён), см. B5.6.

### Локальная очередь (outbox) и ограничения (вариант A — старый)

Чтобы минимизировать риск потери несинхронизированных правок (особенно на iOS), текущая логика разделяет 2 вещи:
1) **Локальное сохранение (IndexedDB)** — всегда.
2) **Доставка на сервер** — либо “сразу” (direct), либо через **outbox**, в зависимости от операции и условий.

Строго:
- Любое действие пользователя в outline‑редакторе **сразу** применяет изменения в UI (TipTap state).
- На каждом автосейве/форс‑флаше клиент **всегда** пишет актуальный `docJson` в IndexedDB (черновик/рабочее состояние) через `updateCachedDocJson(articleId, docJson, preservedUpdatedAt)`.
- В outbox попадают **не все** изменения:
- `structure_snapshot` добавляется debounce‑механизмом: при структурном изменении запускается таймер, и через 650ms в outbox кладётся **последний** snapshot структуры (coalesceKey `structure:{articleId}`).
  - `section_upsert_content` и `delete_sections` добавляются в outbox только когда выбран queue‑путь (оффлайн/нет доступа к серверу) или когда конкретный форс‑флаш “на уход” кладёт их в очередь.

- Outbox коалесится по смыслу:
  - `section_upsert_content` — по секции (`content:<articleId>:<sectionId>`): хранится только последнее состояние секции.
  - `structure_snapshot` — по статье (`structure:<articleId>`): хранится только последний снимок структуры.
- Агрессивный flush: debounce + `blur/visibilitychange` + `online`.
- Фактически: `flushOutboxOnce()` запускается при событии `online`, при уходе вкладки в `hidden`, при `offline-outbox-changed` и один раз на старте; если в outbox остаются ops — включается интервал отправки раз в 7000ms (7 секунд).
- ВАЖНО: запуск UI не должен блокироваться на инициализации offline-базы (IndexedDB). Offline инициализируется в фоне; при долгой инициализации показываем тост “Инициализируем offline-базу…”.

#### Какие операции попадают в outbox (и что именно отправляется)

Outbox хранит **операции**, а не “состояние статьи целиком” (исключение: legacy `save_doc_json`).

Операции outline‑режима:
- `section_upsert_content` → `PUT /api/articles/{articleId}/sections/upsert-content`
  - payload: `{ opId, sectionId, headingJson, bodyJson, seq, createVersionIfStaleHours, clientQueuedAt }`
  - отправляется **только содержимое одной секции** (heading/body TipTap JSON), без структуры.
- `structure_snapshot` → `PUT /api/articles/{articleId}/structure/snapshot`
  - payload: `{ opId, nodes }`, где `nodes[] = { sectionId, parentId|null, position:number, collapsed:boolean }`
  - отправляется **только структура** (parent/position/collapsed), без контента секций.
- `delete_sections` → `PUT /api/articles/{articleId}/sections/delete`
  - payload: `{ opId, sectionIds[] }`
  - отправляются только id удаляемых секций.

Whole‑doc операция `save_doc_json` (**поддерживается синк‑слоем**, но **не используется** регулярным outline‑автосейвом):
- `save_doc_json` → `PUT /api/articles/{articleId}/doc-json/save`
  - payload: `{ docJson, createVersionIfStaleHours, clientQueuedAt }`
  - смысл: отправить **весь docJson целиком** и попросить сервер сохранить “как есть” (это дороже секционных/структурных ops).
  - статус: текущий outline‑автосейв (ветка сохранения outline‑редактора) **никогда** не создаёт `save_doc_json`; вместо этого он шлёт `delete_sections` / `structure_snapshot` / `section_upsert_content`.
  - откуда `save_doc_json` вообще может взяться (строго):
    1) из fallback‑пути функции `saveArticleDocJson()` — она кладёт `save_doc_json` в outbox при сетевой ошибке `PUT /doc-json/save`;
    2) из уже сохранённой очереди outbox в браузере, если она была создана более старой сборкой фронтенда (до перехода на секционные ops) и ещё не была успешно “выпушена”.
  - практическое правило: если `save_doc_json` присутствует в outbox, значит это либо “хвост” старой очереди, либо какой‑то код всё ещё вызывает `saveArticleDocJson()` (что можно найти поиском по `saveArticleDocJson(` в репозитории).

Операции не-outline (структура дерева статей/создание):
- `create_article` → `POST /api/articles` (создание статьи оффлайн, синк позже)
- `move_article_position` → `POST /api/articles/{articleId}/move`
- `indent_article` → `POST /api/articles/{articleId}/indent`
- `outdent_article` → `POST /api/articles/{articleId}/outdent`
- `move_article_tree` → `POST /api/articles/{articleId}/move-tree`

#### Какие запросы идут сразу, а какие через outbox

Не все команды всегда идут через outbox. Есть два режима:

1) **Онлайн (direct)** — если интернет есть и запускается сетевой автосейв, клиент делает запросы **сразу на сервер** через `saveOutlineEditor()`:
   - `delete_sections` отправляется direct только если на момент запуска `saveOutlineEditor()` ещё есть `explicitlyDeletedSectionIds`.
   - `structure_snapshot` отправляется direct только если на момент запуска `saveOutlineEditor()` ещё `structureDirty = true`.
   - `section_upsert_content` отправляется direct по всем секциям, которые находятся в `dirtySectionIds` на момент запуска.
   - важная деталь: форс‑флаш “на уход” (`flushOutlineAutosave`) делает так:
     - если `structureDirty = true` → кладёт `structure_snapshot` в outbox и ставит `structureDirty = false`;
     - если `explicitlyDeletedSectionIds.size > 0` → кладёт `delete_sections` в outbox и очищает `explicitlyDeletedSectionIds`.
     Следствие: при уходе со статьи структура/удаления (если они были) доставляются через outbox, а не direct.

2) **Оффлайн/очередь (outbox)** — если интернета нет или сеть/сервер временно недоступны:
   - те же операции кладутся в outbox и будут отправлены позже в фоне;
   - операции коалессятся, поэтому outbox хранит “последнее намерение” (например, последний snapshot структуры).

Важно (строго): direct и outbox — это не “два разных режима приложения”, а два разных пути **для каждой конкретной операции**. Например, структура чаще уезжает через outbox (debounce), даже если интернет есть.

#### Что делает opId (и что он НЕ делает)

`opId` используется для **идемпотентности** (защиты от повторов), а не для “гарантированного порядка”.

Что гарантирует `opId`:
- если клиент отправит одну и ту же операцию повторно (ретраи outbox, повторная отправка при таймауте, дубли в сети),
  сервер распознает `opId` и **не применит операцию второй раз** (вернёт `status: duplicate`).

Чего `opId` не гарантирует:
- `opId` **не обеспечивает**, что операции будут применены на сервере “в точности в том же порядке, как на клиенте”.
  Причины:
  - outbox коалесит операции (промежуточные состояния могут быть выброшены);
  - операции могут быть разного типа (структура/контент/удаление) и их доставка может прерываться;
  - при нескольких устройствах порядок запросов с разных клиентов не контролируется одним `opId`.

Как реально обеспечивается корректность порядка/устойчивость:
- для контента секции используется `seq` (монотонный счётчик на `(articleId, sectionId)`): сервер игнорирует stale (`seq <= last_seq`);
- для структуры (`structure_snapshot`) семантика “last snapshot wins” (eventual): важен итоговый снимок, а не каждый промежуточный шаг;
- на сервере операции по одной статье выполняются под блокировкой строки (`SELECT ... FOR UPDATE`), чтобы избежать lost updates при конкуренции.

#### Протокол: что происходит при каждом действии (клиент ↔ сервер)

Ниже описаны **строгие** цепочки обмена для трёх операций outline‑редактора. Для каждой операции есть два режима доставки:
- **Direct (онлайн)**: запросы идут на сервер сразу из автосейва.
- **Outbox**: операция кладётся в outbox и будет отправлена позже `flushOutboxOnce()`. Порядок — по `createdAtMs`, но с исключением: `structure_snapshot` **пропускается** в текущем проходе, если с момента предыдущей отправки snapshot по этой статье прошло меньше 3000ms (3 секунды) (throttle).

Общее для всех операций:
- Клиент **всегда сначала** сохраняет текущий `docJson` локально (`IndexedDB`) через `updateCachedDocJson()` (черновик/рабочее состояние).
- Direct‑путь выполняется функцией `saveOutlineEditor()` и применяет операции **последовательно**, но только те, которые “грязные” на момент запуска:
  1) `delete_sections` (если есть `explicitlyDeletedSectionIds`)
  2) `structure_snapshot` (если `structureDirty`)
  3) `section_upsert_content` (по `dirtySectionIds`)
- ВАЖНО: форс‑флаш “на уход” (`flushOutlineAutosave`) **всегда** кладёт `delete_sections`/`structure_snapshot` в outbox, если соответствующие флаги/наборы не пустые, и сбрасывает их до запуска `saveOutlineEditor()`.
  - Если при уходе со статьи интернет доступен и есть изменения контента (`dirtySectionIds`), то `saveOutlineEditor()` отправит контент direct, а структура/удаления (если они были) поедут через outbox.
  - Если при уходе интернета нет (или выбран queue‑путь), то и контент, и структура/удаления поедут через outbox.
- В outbox операции коалессятся по ключам (для структуры и контента секций), поэтому на сервер попадёт **последнее намерение** по этим ключам (а не каждый промежуточный шаг).

##### 1) Upsert содержимого секции (`section_upsert_content`)

**Когда создаётся на клиенте**
- При редактировании текста секции: секция помечается “грязной”.
- При автосейве (debounce) или при уходе/переключении: выбираются все `dirty` секции и для каждой формируется операция.

**Что отправляется на сервер**
- Direct: `PUT /api/articles/{articleId}/sections/upsert-content`
  - body:
    - `sectionId`
    - `headingJson` (TipTap JSON узла заголовка секции)
    - `bodyJson` (TipTap JSON узла тела секции)
    - `seq` (монотонный номер на `(articleId, sectionId)`)
    - `createVersionIfStaleHours`
    - `opId` **не передаётся** в direct‑пути (значит идемпотентность по `opId` на сервере не применяется).
- Outbox: операция `section_upsert_content` кладётся в outbox (coalesceKey `content:{articleId}:{sectionId}`) и позже отправляется тем же endpoint, но с `opId = id операции outbox`.

**Что делает сервер**
- Валидирует пользователя/статью, берёт `FOR UPDATE` на строку статьи.
- Проверяет `seq` по таблице `outline_section_meta` (тоже `FOR UPDATE`):
  - если `seq <= last_seq`: возвращает `{ status: "ignored", reason: "stale", lastSeq }` и **не меняет** документ.
  - если `seq > last_seq`: обновляет/вставляет секцию в `article_doc_json` (заменяет `heading/body`, детей не трогает).
- Обновляет:
  - `articles.article_doc_json`
  - `articles.updated_at`
  - `outline_section_meta.last_seq`
  - FTS индекс секции
  - embeddings секции
  - историю изменений секции (history window)

**Что возвращает сервер**
- Успех: `{ status: "ok", articleId, updatedAt, changedBlockIds: [sectionId], removedBlockIds: [], historyEntriesAdded: [...] }`
- Дубликат по `opId` (только outbox‑повторы): `{ status: "duplicate" }`
- Stale по `seq`: `{ status: "ignored", reason: "stale", lastSeq }`

**Что делает клиент с ответом**
- Direct: берёт `updatedAt` (максимальный из ответов) и вызывает `updateCachedDocJson(articleId, docJson, updatedAt)`; добавляет `historyEntriesAdded` в `state.article.history`; очищает `dirtySectionIds`.
- Outbox: после успешной отправки:
  - патчит локальный кеш `docJson` (подставляет `headingJson/bodyJson` в нужную секцию),
  - пишет `updatedAt` в кеш,
  - удаляет op из outbox.

##### 2) Удаление секций (`delete_sections`)

**Когда создаётся на клиенте**
- При удалении секции в outline‑редакторе id секции добавляется в `explicitlyDeletedSectionIds`.
- При автосейве/уходе со страницы это превращается в операцию удаления.

**Что отправляется на сервер**
- Direct: `PUT /api/articles/{articleId}/sections/delete`
  - body: `{ sectionIds: [ ... ] }` (`opId` в direct‑пути не передаётся).
- Outbox: операция `delete_sections` отправляется тем же endpoint, но с `opId = id операции outbox`.

**Что делает сервер**
- Валидирует пользователя/статью, берёт `FOR UPDATE` на строку статьи.
- Удаляет секции с указанными id из `article_doc_json` (структурно: удаляется целиком узел `outlineSection`).
- Обновляет:
  - `articles.article_doc_json`
  - `articles.updated_at`
  - ссылки статьи (rebuild)
  - FTS и embeddings для удалённых секций (удаление)

**Что возвращает сервер**
- `{ status: "ok", articleId, updatedAt, removedBlockIds: [ ... ] }`
- Дубликат по `opId` (только outbox‑повторы): `{ status: "duplicate" }`

**Что делает клиент с ответом**
- Direct: фиксирует `updatedAt` (для `updateCachedDocJson`), очищает `explicitlyDeletedSectionIds`.
- Outbox: после успеха патчит кеш `docJson` (удаляет секции из дерева), пишет `updatedAt`, удаляет локальные embeddings по `removedBlockIds`, удаляет op из outbox.

##### 3) Изменение структуры (`structure_snapshot`)

**Когда создаётся на клиенте**
- Любое структурное изменение (перемещение/вложенность/сворачивание) ставит `structureDirty = true`.
- Операция создаётся:
- через debounce 650ms после последнего изменения структуры;
  - и принудительно перед уходом со страницы (flush).

**Что отправляется на сервер**
- Direct: `PUT /api/articles/{articleId}/structure/snapshot`
  - body: `{ nodes: [ ... ] }` (`opId` в direct‑пути не передаётся).
- Outbox: операция `structure_snapshot` (coalesceKey `structure:{articleId}`) отправляется тем же endpoint, но с `opId = id операции outbox`.
- Дополнительно: отправка snapshot throttled (не чаще одного раза в 3000ms (3 секунды) на статью); при throttle op пропускается в текущем `flushOutboxOnce()` и уезжает в одном из следующих.

**Что делает сервер**
- Валидирует пользователя/статью, берёт `FOR UPDATE` на строку статьи.
- Применяет структуру к текущему `article_doc_json`:
  - обновляет `parent/position/collapsed` для секций;
  - **не меняет** `headingJson/bodyJson`.
- Обновляет:
  - `articles.article_doc_json`
  - `articles.updated_at`
  - ссылки статьи (rebuild, т.к. зависят от структуры)

**Что возвращает сервер**
- `{ status: "ok", articleId, updatedAt }`
- Дубликат по `opId` (только outbox‑повторы): `{ status: "duplicate" }`

**Что делает клиент с ответом**
- Direct: фиксирует `updatedAt` (для `updateCachedDocJson`), сбрасывает `structureDirty`.
- Outbox: после успеха патчит кеш `docJson` (перестраивает дерево секций по `nodes`), пишет `updatedAt`, удаляет op из outbox.

### Синхронизация outline: секции + структура (вариант A — старый)

Цель: устранить гонки и “whole-doc overwrite”. Критично не терять содержимое секции; структура может быть eventual.

#### Содержимое секции (критично)

- Клиент отправляет `PUT /api/articles/{id}/sections/upsert-content`:
  - `sectionId`
  - `headingJson`, `bodyJson` (только содержимое секции)
  - `seq` — монотонный счётчик на `(articleId, sectionId)` (v1 хранение: `localStorage.ttree_outline_section_seq_v1`; в будущем можно перенести в IndexedDB)
  - `clientQueuedAt` — идентификатор партии (для очистки локального черновика)
- Сервер:
  - игнорирует stale (`seq <= last_seq` из `outline_section_meta`);
  - если секции ещё нет в дереве — создаёт секцию и вставляет в root (в конец);
  - обновляет FTS/embeddings по секции и `articles.updated_at`.

### Тестирование (server)

- Набор pytest-тестов для секционных ops: `tests/test_outline_section_ops.py`.
- Запуск:
  - требуется PostgreSQL и `SERVPY_DATABASE_URL`;
  - `pytest -q`.

#### Структура (некритично, eventual)

- Клиент отправляет `PUT /api/articles/{id}/structure/snapshot` только если структура менялась, но **путь доставки зависит от тайминга**:
- debounce 650ms после последнего структурного изменения кладёт `structure_snapshot` в outbox;
  - если сетевой автосейв стартовал раньше debounce‑таймера — snapshot уходит direct (и debounce‑таймер отменяется);
  - перед уходом со статьи выполняется форс‑флаш: snapshot кладётся в outbox, чтобы не блокировать навигацию.
- Snapshot содержит только `{sectionId, parentId, position, collapsed}` для всех секций.
- Сервер применяет только структуру (parent/position/collapsed), не трогая содержимое ячеек/секций.

### Быстрые заметки (Inbox) и boot‑модалка

Цель: пользователь должен иметь возможность “сразу записать мысль” даже при холодном старте/без сети/до авторизации.

Решение:
- boot‑модалка “Быстрая заметка (оффлайн‑буфер)” пишет **только текст заметок** в `localStorage`:
  - ключ: `ttree_pending_quick_notes_v1`
  - формат: массив `{ id, sectionId, createdAt, text }` (в текущей реализации `id === sectionId` и генерируется сразу).
- на этапе boot **не трогаем IndexedDB** (не блокируем запуск на инициализации offline‑базы).
- после успешной авторизации (и при появлении интернета) приложение синхронизирует эти заметки в Inbox **строго так**:
  1) при открытии/рендере Inbox заметки из `ttree_pending_quick_notes_v1` накладываются поверх `inbox.docJson` на клиенте (чтобы они были видны в UI даже до синка);
  2) фоновый процесс вызывает `enqueuePendingQuickNotesForSync()` и для каждой pending‑заметки ставит в outbox одну операцию `section_upsert_content` с `articleId = "inbox"`:
     - `sectionId` = `note.sectionId`
     - `headingJson/bodyJson` генерируются из текста заметки
     - `seq` берётся из `localStorage.ttree_outline_section_seq_v1`
     - `payload.opId = sectionId` (для идемпотентности на сервере)
  3) `flushOutboxOnce()` отправляет эти ops на сервер; сервер создаёт секции, если их ещё нет в `article_doc_json` Inbox;
  4) после успешной отправки каждой такой операции клиент удаляет соответствующую pending‑заметку из `ttree_pending_quick_notes_v1`.

Компромисс:
- заметки, созданные в boot‑режиме, могут не попадать в локальный поиск до открытия Inbox/синхронизации, потому что boot не обновляет IDB‑индексы.

### Что считается локально, а что на сервере

- Локально (IndexedDB): `articles` (мета + docJson), денорм `outline_sections` (для поиска), локальное хранение `section_embeddings` и ранжирование cosine на клиенте.
- На сервере: вычисление эмбеддингов (ключи/лимиты), публичные ссылки/экспорт, управление доступом, фоновые пересчёты.

### Быстрый API статьи (doc_json-first)

- `GET /api/articles/{id}` отдаёт **doc_json-first**: `docJson` + метаданные, а `blocks` возвращается как пустой массив.
  - Это сильно уменьшает payload и устраняет долгие ответы на больших статьях (раньше строили дерево `blocks` на каждый запрос).
  - Если `docJson` отсутствует/битый — сервер делает self-heal из последней `article_versions.doc_json` (а для `inbox-*` ещё может восстановить из `articles.history`) и возвращает уже заполненный `docJson`.
- Диагностика:
  - сервер добавляет заголовки ответа `X-Memus-Article-ms` и `X-Memus-DocJson-bytes`;
  - клиентский debug включается через `localStorage.ttree_debug_article_load_v1 = "1"` (логи в console: `[api]`, `[article-load]`).

### Поиск в offline-first

- `classic` (обычный) поиск выполняется локально по `outline_sections` (IndexedDB; substring match).
- В v1 используем простой `LIKE/ILIKE` локально.
- `semantic` (векторный) поиск ранжируется **на клиенте**:
  - сервер отдаёт только embedding для запроса (`/api/search/semantic/query-embedding`);
  - embeddings секций синкаются в IndexedDB (`/api/articles/{id}/embeddings`);
  - клиент считает cosine similarity и формирует выдачу.
- Если нет локальных embeddings (первый запуск) или сеть недоступна (нельзя получить query-embedding) — semantic падает обратно на classic/серверный поиск.
- `GET /api/search/semantic` (старый server-side semantic) считается deprecated и может возвращать `410`.

### Медиа (картинки) в offline-first

Цель: офлайн должны быть **все** картинки (`/uploads/...`), а не только “кешированные случайно”.

Решение:
- В клиенте работает Service Worker `TTree/client/uploads-sw.js` с двумя cache storage:
  - `UPLOADS_CACHE` — медиа пользователя (`/uploads/**`) в режиме stale‑while‑revalidate.
  - `APP_CACHE` — app shell (unversioned: `/index.html`, `/style.css`, `/boot.js`, `/app.js`, `/manifest.webmanifest`, иконки, шрифты, а также `/outline/tiptap.bundle.js`).
    - Для `*.js/*.css` используется cache‑first из текущего `APP_CACHE`, чтобы не смешивать версии (часть кода из кеша, часть из сети).
    - Для навигации (`document`) используется быстрый fallback на cached `/index.html`, чтобы приложение стартовало даже на очень медленной сети.
- Фоновая докачка медиа:
  - из `article_doc_json` извлекаются `image.attrs.src`;
  - все `/uploads/...` складываются в `media_refs` (article_id ↔ url) и `media_assets`;
  - отдельная очередь префетча скачивает недостающие файлы с ограниченной конкуррентностью и кладёт их в Cache Storage (`memus-uploads-v1`).
- Повторно не качаем:
  - если файл уже есть в Cache Storage → пропускаем;
  - если статья не изменилась (`updatedAt` совпал) → doc_json повторно не скачиваем.
- Очистка мусора:
  - после full pull выполняется best-effort `pruneUnusedMedia()` (удаляет из cache то, на что нет ссылок в `media_refs`).
- UI/контроль:
  - под заголовком статьи показываем индикатор `Медиа: X/Y` (X = скачано, Y = всего);
  - есть кнопка `Пауза/Продолжить`, которая останавливает/возобновляет фоновую докачку, не влияя на просмотр статей.

### Версия клиента (PWA) и авто‑bump APP_VERSION

Задача: иметь **одну точку** “форс‑обновления” клиентских скриптов и UI‑индикатор версии, чтобы два устройства с одинаковой версией работали на одинаковом app‑shell.

- Источник истины: `TTree/client/uploads-sw.js`
  - `APP_VERSION` — короткий порядковый номер (показывается в UI как `vN`).
  - `APP_CACHE = "a" + APP_VERSION` — имя cache storage для app‑shell.
- Генерация/проверка версии:
  - `npm run gen:app-version` — пересчитывает `APP_BUILD` (хеш содержимого `client/`, включая `uploads-sw.js` за вычетом строк версии) и бампает `APP_VERSION` только если билд реально изменился.
  - `npm run check:app-version` — проверяет, что `APP_BUILD` соответствует текущим исходникам.

#### Сборка фронтенда (bundling `/boot.js` + `/app.js`)

Цель: уменьшить количество запросов и ускорить старт (особенно на медленной сети/мобиле), сохранив правила PWA:
app shell URLs остаются **unversioned**, а обновление клиентов делается только через bump `APP_VERSION` в SW.

Схема:
- Исходники entrypoints:
  - `TTree/client/src/boot.js` → сборка в `TTree/client/boot.js`
  - `TTree/client/src/app.js` → сборка в `TTree/client/app.js`
- Service Worker precache’ит именно итоговые файлы app shell (а не десятки отдельных модулей).
- `TTree/client/outline/tiptap.bundle.js` остаётся отдельным файлом и грузится по требованию; он также кэшируется в app shell для оффлайна.

Команды:
- `npm run build:client` — собирает бандлы `client/boot.js` и `client/app.js` (esbuild).
- `npm run build` — `build:client` → `gen:app-version` → `check:app-version`.

Важно:
- Любые изменения, которые должны попасть в браузер, фиксируются через `npm run build` (это гарантирует обновление `/boot.js`/`/app.js` и корректный bump `APP_VERSION`).
- Скрипты `gen/check/watch` игнорируют `client/src/**` и `*.spec.js/*.test.js` и считают хеш по **шиппимым** артефактам (включая `client/boot.js`, `client/app.js`, `client/style.css`, `client/uploads-sw.js` и т.д.).

#### Watcher как сервис (без git)

Чтобы не помнить про ручной запуск `gen/check`, на сервере может быть запущен watcher, который автоматически бампает `APP_VERSION` при изменениях в **шиппимом** `client/`.
Важно: watcher **не делает bundling**. После правок в исходниках (`client/src/**` или любые модули, попадающие в bundle) нужно сначала выполнить `npm run build`, чтобы обновились `client/boot.js` и `client/app.js` (и только затем будет смысл бампать версию).

- Скрипт watcher: `TTree/scripts/watch_app_version.mjs` (`npm run watch:app-version`).
- systemd user unit (запускается всегда благодаря `linger=yes`):
  - файл: `/home/aadminn/.config/systemd/user/memus-watch-app-version.service`
  - управление:
    - `systemctl --user status memus-watch-app-version.service`
    - `journalctl --user -u memus-watch-app-version.service -f`
    - `systemctl --user restart memus-watch-app-version.service`
    - `systemctl --user disable --now memus-watch-app-version.service`

#### Важно: обновление по обычному F5

ServiceWorker регистрируется ранним бут‑скриптом `TTree/client/boot.js` и основным приложением `TTree/client/app.js`.
Обе регистрации должны использовать `updateViaCache: 'none'`, иначе браузер может “залипать” на старом `uploads-sw.js`,
и UI будет показывать старую версию (например `v18`), хотя на сервере уже `v20`.

---

## Инцидент: потеря серверной БД и восстановление (2026‑01)

### Что произошло

- На сервере используется PostgreSQL база `ttree`.
- В процессе разработки/тестов тестовый раннер был запущен против реальной базы (не против отдельной test DB).
- В результате в `ttree` остались только свежесозданные пользователи/статьи, а основная коллекция статей пропала.

Практическое проявление в UI:
- после авторизации “kirill” видит пустую базу и 1–2 статьи;
- при этом на клиенте могут сохраниться статьи в IndexedDB (offline cache), но они “не совпадают” с новым `userKey` (`users.id`), поэтому выглядят как “пропали”.

### Как восстановили данные

1) **Найти старую локальную offline-базу**
- Локальные базы IndexedDB называются `memus_offline_v1_<userKey>`.
- На “пострадавшем” устройстве был обнаружен старый `userKey` с ~200+ статей.

2) **Вернуть `userKey` на сервере**
- Серверный `users.id` для пользователя `kirill` был приведён обратно к старому `userKey`, чтобы:
  - совпали пути `/uploads/<userKey>/...` в docJson;
  - клиент “естественно” использовал правильную локальную IndexedDB без специальных режимов.

---

## Инцидент: деградация inbox (часть секций стала пустой/пропала)

### Симптом

- `/api/articles/inbox` начал возвращать inbox, где часть секций пустая (heading/body), а часть секций вообще пропала.
- Локально на одном из устройств секции ещё были (в IndexedDB), но это **не должно** быть источником правды.

### Причина

Мы одновременно использовали две “истины” для одной и той же сущности inbox:

- **Новая схема (outline-first):** статья хранится в `articles.article_doc_json` и изменяется через `save_article_doc_json()`.
  При этом таблица `blocks` *не обновляется* при редактировании в outline-редакторе.
- **Старая схема (legacy blocks):** некоторые интеграции (в частности Telegram‑бот) вставляли/читали данные через таблицу `blocks`,
  а затем пересобирали `docJson` из `blocks`.

Когда `docJson` был пересобран из `blocks`, в него попали только те секции, которые существовали в `blocks`,
а “outline‑секций” (которые никогда не писались в `blocks`) не стало. Плюс в `blocks` мог быть “дефолтный” пустой блок → секции становились пустыми.

### Восстановление (server-side)

Серверный ремонт выполняется только из серверных данных (сервер — центр правды):

- Скрипт: `TTree/scripts/repair_inbox_from_server.py`
- Источники:
  - текущий `articles.article_doc_json`
  - `articles.history` (outline-first записи по секциям)
  - `article_versions.doc_json` (снапшоты)
- Запуск:
  - `PYTHONPATH=/home/aadminn/Ttree/TTree python3 scripts/repair_inbox_from_server.py <user_id>`

### Профилактика

- Telegram‑бот и другие интеграции для inbox должны работать **docJson-first** (не через `blocks`), чтобы не “съедать” секции.

3) **Залить статьи обратно на сервер**
- Восстановление делали batch‑процедурой на клиенте (временный recovery UI):
  - `POST /api/articles` с `id` и `title` (сервер принимает client‑supplied `id`);
  - затем `PUT /api/articles/{id}/doc-json` с `docJson` (лёгкая запись без тяжёлых индексов);
  - после этого статьи перестали быть `404` и стали открываться “как обычные”.

Важно:
- Это восстановило контент (`articles.article_doc_json`), но не гарантирует восстановление всех медиа‑файлов на диске сервера (если они были удалены вместе с окружением).

### Почему recovery‑кнопки нет в интерфейсе

Recovery‑кнопка опасна:
- может случайно перезаписать серверную базу/структуру (особенно если запускать в неправильном аккаунте/на неправильном устройстве);
- может создать много серверных записей и нагрузку.

Поэтому кнопку **нельзя** держать “скрытой” — её не должно быть в UI вообще. Если понадобится — включаем только целенаправленно на время инцидента.

### Как вернуть recovery‑кнопку (временно, вручную)

1) В `client/boot.js` в `showQuickNoteModal()` добавить кнопку в `actions`:
- создать `recoverBtn` (например `textContent = 'Восстановление…'`) и `actions.appendChild(recoverBtn)`.
2) Подключить обработчик клика:
- `recoverBtn.addEventListener('click', showRecoveryModal)`.
3) Поднять версию `boot.js` в `client/index.html` (query‑string `boot.js?v=...`), чтобы клиенты получили новую версию.
4) После использования удалить кнопку обратно.

---

## Бэкапы PostgreSQL (server)

### Где что лежит

- База: PostgreSQL, database = `ttree`.
- Скрипты бэкапа (на сервере): `/home/aadminn/pg_backups/`
  - `/home/aadminn/pg_backups/backup_ttree.sh` — ежедневный `pg_dump` (logical backup).
  - `/home/aadminn/pg_backups/basebackup_ttree.sh` — еженедельный `pg_basebackup` (physical backup).
- Артефакты:
  - дампы: `/home/aadminn/pg_backups/ttree_*.dump`
  - basebackup: `/home/aadminn/pg_backups/basebackup/ttree_*` (директории)

### Цикличность (retention)

Ротация реализована внутри скриптов:
- `pg_dump`: хранится только последние ~30 файлов (`tail -n +31 | rm`).
- `pg_basebackup`: хранится только последние ~8 директорий (`tail -n +9 | rm -rf`).

### Cron

Cron‑задачи установлены в crontab пользователя `aadminn`:
- ежедневный дамп (пример): `10 2 * * * /home/aadminn/pg_backups/backup_ttree.sh`
- еженедельный basebackup (пример): `10 3 * * 0 /home/aadminn/pg_backups/basebackup_ttree.sh`

### Самовосстановление doc_json (чтобы публичные статьи не становились пустыми)

- Публичный рендер и outline-режим используют `articles.article_doc_json` как источник истины.
- Если у статьи `article_doc_json` отсутствует/битый:
  - сервер восстанавливает `doc_json` из последней `article_versions.doc_json`;
  - для `inbox-*` дополнительно может восстановить docJson из `articles.history` (если есть).

## Горячие клавиши (обязательные)

- `Alt+↑/↓`: переместить текущую секцию среди sibling’ов (вверх/вниз).
- `Alt+→/←`: indent/outdent секции (смена уровня вложенности в дереве) + нормализация дерева.
- `Ctrl+→/←`: collapse/expand текущей секции.
- `Ctrl+↑`: схлопнуть **родительскую** секцию (и всех детей внутри неё).
- `Ctrl+↓`: развернуть **текущую** секцию (и всех её детей).
- `Space` (только view-mode, когда фокус внутри outline): toggle collapsed у текущей секции.

Примечания:
- Если текущая секция свернута — `Ctrl+→` разворачивает, `Ctrl+←` сворачивает (направления можно инвертировать, но должны быть консистентны).
- Для macOS желательно дополнить альтернативами (`Meta`/`Alt`) позже, но в этом ТЗ фиксируем базовые комбинации.

## “Умный Enter” (создание новой секции без отдельной команды)

### Поведение

Внутри `body` текущей секции:
- `Enter` обычно создаёт новый абзац (как в обычном редакторе).
- Если курсор находится в **пустом последнем абзаце body** и пользователь нажимает `Enter` ещё раз (то есть это **третье Enter подряд** в конце секции):
  - вместо добавления ещё одного пустого абзаца создаётся **новая секция-сиблинг** после текущей;
  - новая секция создаётся на той же глубине (sibling текущей секции) и сразу переводится в режим редактирования (курсор в её заголовке).

### Условия срабатывания (детерминированные)

Срабатывание допускается только когда выполняются все условия:
- курсор находится внутри `body` ноды `section`;
- текущий параграф пустой (после нормализации: нет видимого текста/медиа);
- параграф является последним блоком внутри `body`;
- на момент обработки уже есть состояние “предыдущий Enter был в этом же месте” (anti-accidental).

### Визуальная подсказка

Новая секция создаётся с пустым заголовком, но UI должен показывать плейсхолдер заголовка (например, “Заголовок…”), чтобы пользователь не воспринимал это как “абзац без заголовка”.

## Split секции (разбиение)

- `Ctrl+Enter`: разбиение секции в позиции курсора.
  - Если курсор в `body`: создаётся новая секция ниже, в неё переносится “хвост” body после курсора и **все children** исходной секции.
  - Если курсор в `heading`: заголовок делится на две секции, при этом body+children переносятся в новую (вторую) секцию.

## Списки (UX)

- `Enter` внутри `li` по умолчанию создаёт новый `li` (поведение ProseMirror).
- Чтобы превратить новый `li` в “второй абзац предыдущего пункта”, нажмите `Backspace` в начале `li`:
  содержимое текущего `li` будет перенесено как **новый абзац** в конец предыдущего `li` (без склейки в одну строку).

## Модель документа (ProseMirror/TipTap)

## Изображения (uploads + resize)

- В outline режиме вставка/дроп изображения должна работать как в старом режиме:
  - файл загружается на сервер через `POST /api/uploads` (сервер ресайзит до max width 1920 и конвертирует в WebP);
  - в документ вставляется картинка с `src=/uploads/...`;
  - ширина картинки вручную меняется “хэндлом” (drag вправо/влево) и сохраняется в документе.
- При вставке картинка обрамляется пробелами (слева/справа), чтобы можно было сразу вводить текст до/после изображения.
- В текущей реализации вставляем по два пробела слева/справа (чтобы точно было место под ввод).
- UI/стили ресайза используются те же, что и в старом режиме (`.resizable-image`, `.resizable-image__handle`).
- В режиме просмотра клик по картинке открывает увеличенный просмотр (как в старом режиме).

### Нода `section`

`section` — блочная нода, содержащая:
- `heading` (обязательный, ровно один);
- `body` (контейнер для контента секции, без заголовков);
- `children` (контейнер для вложенных `section`).

Рекомендуемая форма (схематично):

- `doc: section+`
- `section: heading body children`
- `heading: sectionHeading(id=sectionId) inline*`
- `body: block*` (paragraph/list/table/image/etc; **без** heading/section)
- `children: section*`

### Атрибуты секции

`section.attrs`:
- `id: string` — устойчивый идентификатор секции (единица смысла; соответствует `block_id` на сервере).
- `collapsed: boolean` — состояние свёрнутости.

Примечание про “уровень заголовка”:
- Пользователь **не выбирает** стиль/уровень заголовка (h1/h2/…).
- Визуальный “уровень” секции считается **на лету** по глубине вложенности (depth) при отрисовке.
- Для стилизации используем максимум 6 уровней (clamp `1..6`), больше не требуется.

### Инварианты (обязательная нормализация)

Документ должен удовлетворять:
- `section` всегда содержит `heading` (не пустую ноду, но текст заголовка может быть пустым во время редактирования).
- `section` всегда содержит `heading` (узел обязателен; текст заголовка может быть пустым во время редактирования).
- Внутри `body` **не может** быть `heading` или `section`.
- Дочерние секции живут только внутри `children`.
- Порядок: `heading` всегда над `body`, а `children` всегда после `body`.

Нужен нормализующий плагин, который после транзакций чинит нарушения (paste/drop/join/удаления):
- если `heading` попал в `body`, он должен быть преобразован в новую `section` (с корректным `id`) в `children` или sibling в зависимости от контекста;
- если `section` нарушила структуру, приводим к `section(heading, body, children)` минимальными правками.

## Сворачивание секций

- Сворачивание работает на уровне `section.attrs.collapsed`.
- В свернутом состоянии:
  - заголовок секции видим;
  - `body + children` скрыты (визуально), но остаются в документе (не удаляются).
- Кнопка/гаттер у заголовка должна менять `collapsed`.
- Горячие клавиши `Ctrl+→/←` должны менять `collapsed` у текущей секции.

## Перемещение и изменение вложенности

### Перемещение среди sibling’ов: `Alt+↑/↓`

Команда перемещает целиком текущую `section`:
- вверх/вниз относительно sibling’ов в том же `children` контейнере;
- переносит вместе `body` и всем поддеревом `children`.

### Indent/Outdent: `Alt+→/←`

Команды меняют вложенность секции в дереве (и как следствие её визуальный уровень).

Определения:
- `indent` делает секцию ребёнком предыдущей подходящей секции (как в outliner).
- `outdent` поднимает секцию на уровень выше (делает sibling’ом родителя).

UX-правило видимости:
- если при `indent` новый родитель был свёрнут, он автоматически разворачивается, чтобы перенесённая секция оставалась видимой.

После операции применяется нормализация outline-дерева:
- дерево всегда валидно по схеме `section(heading, body, children)`;
- глубина для стилей ограничивается 6 уровнями (визуально), но структура может быть ограничена логикой UI (не более 6 фактических уровней вложенности).

## Правила удаления/склейки (чтобы не “потеряться”)

Дополнительно (UX-guard):
- Если пользователь выделяет тело секции через `Shift+↓` и нажимает `Delete/Backspace`,
  удаляем только выделение **внутри body текущей секции** и не даём редактору “съесть границу”,
  чтобы следующая секция не превращалась в часть body предыдущей.

### Удаление заголовка

Так как “секции без заголовков” не допускаются, пустой заголовок секции не должен превращать её в “беззаголовочную секцию” в финальном результате.

Рекомендуемое правило:
- если заголовок секции пустой и пользователь продолжает удаление (Backspace в начале заголовка / удаление узла):
  - секция **сливается в предыдущую**:
    - её `body` добавляется в конец `body` предыдущей секции;
    - её `children` становятся следующими секциями после добавленного `body` (как часть children предыдущей секции).

UX для пустого заголовка при редактировании:
- Пока заголовок пустой, вместо текста заголовка показываем:
  - иконку/маркер “без названия”, и/или
  - автосгенерированное название-подсказку (например, из первых N символов body).
- При уходе курсора из секции, если заголовок всё ещё пустой, можно автоматически предложить/поставить заголовок,
  сгенерированный дешёвой моделью OpenAI по `plain(body)` (ограничение 200 символов, русский).
  Для зашифрованных статей эта генерация отключена (не отправляем plaintext наружу).

### Авто-исправление ошибок (proofread) при выходе из секции

Если пользователь **покинул секцию** (курсор ушёл в другую секцию) и при этом **в секции были изменения**:
- отправляем `body` текущей секции (HTML) в `gpt-4o-mini` на “исправление ошибок”;
- применяем ответ обратно в `body` секции;
- ничего не делаем для зашифрованных статей (не отправляем plaintext/HTML наружу).

Ключевые ограничения промпта (обязательны):
- не добавлять новые слова, не удалять существующие, не менять порядок слов;
- можно удалять только повторы подряд идущих одинаковых слов;
- не нарушать существующую HTML-разметку;
- исправлять орфографию/пунктуацию/заглавные/повторы/согласование (только заменами существующих слов).
- При `Save`, если заголовок пустой, подставлять сгенерированный заголовок в документ (чтобы не сохранять “пустые заголовки”).
  Рекомендуемый алгоритм: взять `plain(body)` → первая непустая строка/предложение → обрезать до ~80 символов → если пусто, использовать “Без названия”.

### Склейка секций

Склейка возможна через `Backspace` в начале заголовка:
- merge with previous section (как в outliner).

Если секция — первый child (предыдущего sibling нет), то `Backspace` в начале заголовка:
- удаляет секцию,
- переносит её заголовок+body в конец `body` родителя,
- а её children поднимает на уровень родителя (в начало children родителя).

При merge:
- сохраняется предсказуемость: итоговая секция остаётся “одной единицей смысла” (id предыдущей), а удалённая секция считается удалённой/влитой.

## Индексация и embeddings

### Сегментация текста

Для каждой секции `S` строим:
- `title_plain = plain(heading(S))`
- `body_plain = plain(body(S))`
- `index_text = (title_plain + "\n" + body_plain).trim()`

`children` не включаем.

### Пустые секции

- Если `index_text` пустой: секция не индексируется/embedding удаляется (как “пустой блок”).
- Если пустое тело, но есть заголовок: индексируем по заголовку.

## История секций (per-section)

Цель: дать пользователю “историю изменения именно этого блока” независимо от глобального undo.

Рекомендация:
- хранить историю не как попытку “извлечь шаги из ProseMirror history”, а как **ревизии на сохранении**:
  - при `Save` сравнить старый и новый `index_text` (или JSON) для каждой `section.id`;
  - если изменилось — записать историю `before/after` по `section.id` с timestamp и ссылкой на статью.

Практическая UX-логика:
- пользователь не нажимает “сохранить блок”;
- при уходе курсора из секции мы считаем, что секция “закоммичена” и запускаем автосохранение статьи батчем;
- сервер всё равно атомарно сохраняет весь документ/дерево, но историю пишет по изменившимся секциям.

Реализация (текущее):
- В меню статьи есть “История блока…”, которая показывает историю изменений текущей секции/блока (по `section.id`).
- История пишется на сервере при сохранении:
  - `section_upsert_content` (контент секции),
  - и/или при сохранении `article_doc_json` (полный снапшот статьи).
- Конфликты (`UpsertAck.result:"conflict"`) не попадают в историю: вместо этого создаётся “конфликтная копия” секции в тексте статьи (см. Variant B, B9).
- Восстановление восстанавливает состояние “после выбранного изменения” и в outline-режиме правит TipTap-документ (только `heading/body`, дети сохраняются), затем уходит в автосейв.
- Вся старая история HTML-блоков очищается (одноразовая миграция в `schema.py`, ключ `schema_meta.purged_legacy_block_history_v1`).

### Скольжение истории (windowed revisions) (вариант A — старый)

Задача: пока пользователь активно редактирует секцию, не писать “каждый автосейв” в историю (для этого есть Undo/Redo).

Правило на сервере (вариант A — старый):
- При поступлении нового изменения секции сервер применяет его (если `seq > last_seq`).
- История пишется как “окна” по секции:
  - если окно начато < 1 часа назад → обновляем `after*` в последней записи окна (before остаётся прежним), добавляем `updatedAt`;
  - иначе создаём новую запись истории и начинаем новое окно.

Состояние окна хранится в `outline_section_meta`:
- `history_window_started_at`
- `history_window_entry_id`

## Вложения (Yandex Disk) в outline

- Drop/Paste не‑картинок внутри секции в режиме редактирования загружает файл как вложение на Яндекс.Диск (как в старом режиме) и вставляет ссылку в текст.
- В view-mode дроп файлов не должен уводить пользователя со страницы (есть глобальный guard на drag&drop).

## Версии статьи (snapshots)

### Что такое “Версия”

- “Версия” — это **полная копия статьи** (полный snapshot содержимого и структуры) в момент времени.
- Версия используется для:
  - “зафиксировать состояние”;
  - сравнить изменения;
  - откатить статью к сохранённой версии.

### Хранение версии

На первом этапе (без коллаборации и без TipTap Cloud/Yjs):
- версию сохраняем как данные статьи целиком:
  - предпочтительно: TipTap `doc_json` (схема outline),
  - допустимо временно: материализованное дерево блоков Memus (как сейчас хранится на сервере),
  - плюс метаданные: `created_at`, `author_id`, `label` (опционально), `reason` (manual/auto).

Важно:
- Для “Версий” мы **не используем** tiptap collaboration plugins (snapshot/compare из документации TipTap), потому что они рассчитаны на Yjs/коллаборацию.
- Когда появится хранение `doc_json` на сервере, можно сделать сравнение версий на базе JSON (или через будущий tooling).

### Параллельное хранение `article_doc_json`

- На сервере хранится `articles.article_doc_json` (TipTap JSON документа), обновляется параллельно с материализацией дерева блоков.
- В “Версиях” дополнительно сохраняется `article_versions.doc_json` (TipTap JSON на момент версии), чтобы в будущем дифф/восстановление можно было делать точнее.
- Для зашифрованных статей `doc_json` не сохраняем (чтобы не хранить plaintext на сервере).

### Миграция всех статей в `doc_json`

- Скрипт конвертирует существующие `blocks.text` (HTML) в `articles.article_doc_json` для всех статей, у которых `doc_json` ещё не заполнен.
- Команда:
  - `cd TTree && python3 -m servpy.app.migrate_doc_json_from_blocks`
  - Опционально можно передать `limit` (число статей): `python3 -m servpy.app.migrate_doc_json_from_blocks 50`
- Дополнительно:
  - `--dry-run` — прогнать конвертацию без записи в БД;
  - `--force` — перезаписать `article_doc_json` даже если он уже заполнен (опасно; использовать только если точно уверены, что `blocks` — источник истины).
- Требования: установлен `node` и выполнен `npm install` в `TTree/` (конвертер использует локальные зависимости TipTap и `happy-dom`).
- Если в будущем появятся зашифрованные статьи, их мигрировать нельзя без расшифровки.

### Семантические embeddings: источник текста

- Семантический индекс (`block_embeddings`) строится из `articles.article_doc_json`, по секциям `outlineSection.attrs.id`.
- Текст секции для embeddings = `plain(heading) + "\n" + plain(body)` (без детей).
- Legacy `blocks` не используется в runtime: embeddings всегда по `section_id` из docJson.

### FTS (обычный поиск): `outline_sections_fts`

- Обычный поиск по содержимому блоков работает через таблицу `outline_sections_fts`.
- Индексируемая единица = секция (`outlineSection.attrs.id`), то есть тот же `blockId`.
- Храним:
  - `text` — plain-text секции (heading+body, без детей),
  - `lemma` и `normalized_text` (как и в старом FTS),
  - `search_vector` (tsvector) + GIN индекс.
- Переиндексация: `python3 -m servpy.app.reindex_fts` (пересобирает `articles_fts` и `outline_sections_fts`).

### `article_links` (внутренние ссылки)

- Внутренние ссылки на статьи извлекаются из `article_doc_json`:
  - TipTap mark `link` с `href="/article/<uuid>"` (или абсолютный URL `https://memus.pro/article/<uuid>`).
- Сохраняем в `article_links(from_id, block_id=section_id, to_id, kind='internal')`.

### Когда создаётся версия

- Вручную: команда пользователя “Сохранить версию”.
- Автоматически: **перед первым изменением** после долгого перерыва (≥ 12 часов с момента последнего изменения статьи).
  - То есть: как только пользователь начинает править статью после паузы, мы сначала создаём версию “как было”, затем продолжаем редактирование.

### UI (минимально)

- В меню статьи есть:
  - “Сохранить версию” (создать manual snapshot; опционально спросить `label`, можно пустой);
  - “Версии…” (открывает список версий и позволяет восстановить выбранную, а также показать отличия: версия ↔ текущая или версия ↔ версия).

Сравнение версий:
- диалог сравнения открывается почти на весь экран;
- диалог сравнения всегда в светлой теме (вне зависимости от общей темы интерфейса);
- отличающиеся фрагменты подсвечиваются цветом.

Минимальная модель ревизий:
- `section_id`
- `article_id`
- `before_plain` / `after_plain` (или `before_html` / `after_html`, или `before_json` / `after_json`)
- `saved_at`

Эта история используется для:
- UI “история блока”;
- потенциального отката конкретного блока к ревизии (вставка ревизии обратно в документ).

## Миграция с текущей модели Memus

### Стартовое состояние

Сейчас Memus хранит:
- дерево блоков статьи на сервере (каждый блок содержит HTML `text`, `collapsed`, `children`, `id`);
- FTS-индекс по секциям строится из `articles.article_doc_json` (outlineSection: heading+body, без детей) и хранится в `outline_sections_fts`.
- semantic embeddings строятся из `articles.article_doc_json` (см. раздел выше).

### Переход к документу TipTap

Переход рекомендуется делать постепенно:

1. Добавить хранение полного TipTap-документа на статью (например, `article_doc_json` / `article_doc_html_snapshot`).
2. Для обратной совместимости и индекса:
   - при сохранении TipTap-документа материализовать дерево секций в текущий формат блоков;
   - **не** привязывать индексы к HTML: считать embeddings/FTS из `article_doc_json` и держать отдельную индекс‑таблицу по секциям.
3. После стабилизации можно решить, остаётся ли материализация навсегда (для быстрого поиска/совместимости), или индексация будет считаться напрямую из TipTap JSON.

Текущее поведение (реализация):
- `GET /api/articles/{id}` возвращает `docJson` (если статья не зашифрована и он есть в БД).
- Outline-редактор при открытии:
  - сначала пытается открыть документ из `docJson`;
  - если `docJson` отсутствует — конвертирует дерево блоков в outline-doc и **один раз** сохраняет `docJson` отдельным запросом (без переписывания blocks), чтобы дальше открываться 1:1.
  - bootstrap делается через `PUT /api/articles/{id}/doc-json`.

Рендер/экспорт/публичный рендер (doc_json-first):
- Экспорт статьи в HTML делается на сервере из `article_doc_json`: `GET /api/articles/{id}/export/html` (HTML самодостаточный: `/uploads/...` инлайнится в `data:`).
- Экспорт всех статей в ZIP (`/api/export/html-zip`) использует тот же рендерер и тоже основан на `article_doc_json`.
- Публичная страница (`/p/<slug>`) использует **те же клиентские скрипты, что и outliner** (`/outline/editor.js`), но включает строгий read-only режим (без входа в edit-mode, без автосейва).
- В публичном просмотре не показываем верхнюю панель outliner’а (`.outline-editor__bar`).
- Для 1:1 визуала публичная страница монтирует outliner в контейнер с классом `.outline-editor` (там объявлены CSS-переменные для рамок/цветов секций).
- Перед монтированием outliner сервер переписывает внутренние ссылки в `doc_json`: `/article/<id> → /p/<slug>`, а если статья не опубликована — `href="#"` и `rel+="unpublished"` (клик показывает алерт).
- Экспорт/ZIP остаются server-side и продолжают рендериться из `article_doc_json` (Node renderer → Python fallback при необходимости).

Kill-switch для проверки отказа от `blocks`:
- Если установить `SERVPY_BLOCKS_KILL_SWITCH=1`, сервер будет падать на любой runtime SQL-запрос, который обращается к таблицам `blocks`/`blocks_fts` (DDL в `schema.py` разрешён).

### Конвертация “старые блоки → section doc”

При первом открытии статьи в новом редакторе:
- строим документ из текущего дерева блоков:
  - каждый блок сервера становится `section` с `id=block.id`, `collapsed=block.collapsed`;
  - заголовок блока (если есть) превращается в `sectionHeading` (визуальный уровень считается по depth);
  - если заголовок отсутствовал в старой модели — подставляется синтетический заголовок (например, “Без названия”) или автогенерация из body.
  - тело блока переносим в `body`;
  - `children` блока — в `children` секции.

## Нефункциональные требования

- Работает на мобильных браузерах (IME/selection/paste стабильны).
- Держит большие статьи (сотни/тысячи секций) без деградации UX (виртуализация обсуждается отдельно).
- Данные секций (`id`) должны быть стабильны при:
  - перемещении;
  - изменении вложенности;
  - сворачивании;
  - редактировании текста;
  - вставке/пасте контента.

## Acceptance Criteria (минимальный PoC)

1. В статье можно создавать секции: заголовок + body, включая умный Enter.
2. Любая секция сворачивается/разворачивается мышью и `Ctrl+→/←`.
3. `Alt+↑/↓` переносит секцию среди sibling’ов без потери детей.
4. `Alt+→/←` меняет вложенность секции, дерево нормализуется предсказуемо.
5. Для каждой секции вычисляется `index_text` как title+body без детей.
6. При сохранении фиксируются ревизии секций, доступные для “истории блока”.

7. Автосейв:
- изменения сохраняются автоматически и не требуют кнопки “Сохранить”;
- при уходе со статьи происходит форс-флаш;
- при ошибке сохранения создаётся локальная очередь и повтор.

8. Версии:
- можно вручную создать версию статьи;
- если статья не менялась ≥12 часов, то перед первой правкой создаётся автоверсия.
