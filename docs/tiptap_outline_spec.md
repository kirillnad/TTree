# ТЗ: Outline-редактор на TipTap (секции по заголовкам)

## Цель

Сделать редактирование статьи как одного документа TipTap, где структура (дерево) **рождается из заголовков** и выглядит для пользователя как “структурированный текст”.

Каждая секция (заголовок + тело + дети) — **единица смысла**:
- используется как отдельный “блок” для поиска и embeddings;
- имеет устойчивый `id`;
- поддерживает сворачивание/разворачивание;
- поддерживает перемещение среди sibling’ов и смену уровня вложенности.

## Термины

- **Документ** — TipTap/ProseMirror `doc` для всей статьи.
- **Блок** — единица смысла в Memus: `heading + body + children` + `collapsed` + устойчивый `id`.
- **Секция (`section`)** — нода TipTap/ProseMirror, реализующая “блок” в документе (внутренний технический термин).
- **Единица смысла** — то, что индексируется и эмбеддится (равно секции).
- **Тело секции (`body`)** — контент секции, **не включая** дочерние секции.

## Принципы и ключевые решения

1. **Секции только с заголовками**  
   Секции без заголовков не допускаются (они визуально путают уровни).  
   “Intro” не является отдельной беззаголовочной секцией: роль intro выполняет **название статьи** (UI вне документа).

2. **Embeddings/поиск: только title + body (без детей)**  
   Для секции `S`: текст для индекса/эмбеддинга = `plain(title(S)) + "\n" + plain(body(S))`, **без** текстов дочерних секций.

3. **Структура хранится явно, не эвристикой**  
   В документе должна существовать явная нода `section` (а не “угадывание секций” по голым `heading/paragraph`).
   Это снижает риск “потеряться” после сложных операций (split/merge/move/paste).

3.1. **Уникальные идентификаторы секций**  
   Для `outlineSection` используется `UniqueID` (TipTap) для:
   - генерации `id` для новых секций;
   - автоматической замены `id` при paste/drag-copy (чтобы не появлялись дубликаты).

4. **Глобальный undo по статье + история по секции**  
   - Undo/redo по статье — стандартный ProseMirror `history`.
   - “История изменений именно секции” — хранится как ревизии на сохранении (см. раздел “История секций”).
   - “Сохранение секции” как UX-событие: ревизия секции фиксируется естественно при уходе курсора из секции (не отдельной кнопкой).

5. **Статья не требует явного сохранения**  
   Пользователь не должен нажимать “Сохранить/Отменить”.  
   Текст сохраняется автоматически, а “Версии” — отдельный механизм (см. ниже).

## UX: как это выглядит для пользователя

- Статья выглядит как структурированный текст с заголовками.
- У каждого заголовка есть контроль сворачивания/разворачивания содержимого секции (тело + дочерние секции).
- Пользователь создаёт структуру естественно: **заголовок = новая секция**.
- Внутри секции `Enter` создаёт новые абзацы **в теле**, не “новый блок”.

## Сохранение (автосейв)

### Принцип

- Сохранение статьи происходит **автоматически** (debounce) и не требует действий пользователя.
- Единственная “явная” сущность, которую пользователь может сохранять руками — это **Версия** (snapshot).

### Триггеры автосейва

- Любое изменение документа: debounce ~1–2 секунды.
- Уход со статьи / переключение на другую статью / `blur` окна: форс-флаш очереди (без диалогов).

### Гарантии при сбоях

- Если сеть/сервер недоступны: изменения складываются в простую **локальную очередь** (пока `localStorage`).
- При восстановлении соединения или следующем удобном случае очередь “догоняется”.
- В будущем (offline-first) очередь переносится в IndexedDB, но в этом ТЗ — “как проще”.

### UI (минимально)

- Нет кнопок “Сохранить” и “Отменить” в редакторе статьи.
- Можно показывать неблокирующий статус: “Сохраняется… / Сохранено / Ошибка, повторим”.

## Горячие клавиши (обязательные)

- `Alt+↑/↓`: переместить текущую секцию среди sibling’ов (вверх/вниз).
- `Alt+→/←`: indent/outdent секции (смена уровня вложенности в дереве) + нормализация дерева.
- `Ctrl+→/←`: collapse/expand текущей секции.
- `Ctrl+↑/↓`: collapse/expand текущей секции + всех её детей.

Примечания:
- Если текущая секция свернута — `Ctrl+→` разворачивает, `Ctrl+←` сворачивает (направления можно инвертировать, но должны быть консистентны).
- Для macOS желательно дополнить альтернативами (`Meta`/`Alt`) позже, но в этом ТЗ фиксируем базовые комбинации.

## “Умный Enter” (создание новой секции без отдельной команды)

### Поведение

Внутри `body` текущей секции:
- `Enter` обычно создаёт новый абзац (как в обычном редакторе).
- Если курсор находится в **пустом последнем абзаце body** и пользователь нажимает `Enter` ещё раз:
  - вместо добавления ещё одного пустого абзаца создаётся **новая секция-сиблинг** после текущей;
  - новая секция создаётся на той же глубине (sibling текущей секции) и фокусом в её заголовок.

### Условия срабатывания (детерминированные)

Срабатывание допускается только когда выполняются все условия:
- курсор находится внутри `body` ноды `section`;
- текущий параграф пустой (после нормализации: нет видимого текста/медиа);
- параграф является последним блоком внутри `body`;
- на момент обработки уже есть состояние “предыдущий Enter был в этом же месте” (anti-accidental).

### Визуальная подсказка

Новая секция создаётся с пустым заголовком, но UI должен показывать плейсхолдер заголовка (например, “Заголовок…”), чтобы пользователь не воспринимал это как “абзац без заголовка”.

## Модель документа (ProseMirror/TipTap)

### Нода `section`

`section` — блочная нода, содержащая:
- `heading` (обязательный, ровно один);
- `body` (контейнер для контента секции, без заголовков);
- `children` (контейнер для вложенных `section`).

Рекомендуемая форма (схематично):

- `doc: section+`
- `section: heading body children`
- `heading: sectionHeading(id=sectionId) inline*`
- `body: block*` (paragraph/list/table/image/etc; **без** heading/section)
- `children: section*`

### Атрибуты секции

`section.attrs`:
- `id: string` — устойчивый идентификатор секции (единица смысла; соответствует `block_id` на сервере).
- `collapsed: boolean` — состояние свёрнутости.

Примечание про “уровень заголовка”:
- Пользователь **не выбирает** стиль/уровень заголовка (h1/h2/…).
- Визуальный “уровень” секции считается **на лету** по глубине вложенности (depth) при отрисовке.
- Для стилизации используем максимум 6 уровней (clamp `1..6`), больше не требуется.

### Инварианты (обязательная нормализация)

Документ должен удовлетворять:
- `section` всегда содержит `heading` (не пустую ноду, но текст заголовка может быть пустым во время редактирования).
- `section` всегда содержит `heading` (узел обязателен; текст заголовка может быть пустым во время редактирования).
- Внутри `body` **не может** быть `heading` или `section`.
- Дочерние секции живут только внутри `children`.
- Порядок: `heading` всегда над `body`, а `children` всегда после `body`.

Нужен нормализующий плагин, который после транзакций чинит нарушения (paste/drop/join/удаления):
- если `heading` попал в `body`, он должен быть преобразован в новую `section` (с корректным `id`) в `children` или sibling в зависимости от контекста;
- если `section` нарушила структуру, приводим к `section(heading, body, children)` минимальными правками.

## Сворачивание секций

- Сворачивание работает на уровне `section.attrs.collapsed`.
- В свернутом состоянии:
  - заголовок секции видим;
  - `body + children` скрыты (визуально), но остаются в документе (не удаляются).
- Кнопка/гаттер у заголовка должна менять `collapsed`.
- Горячие клавиши `Ctrl+→/←` должны менять `collapsed` у текущей секции.

## Перемещение и изменение вложенности

### Перемещение среди sibling’ов: `Alt+↑/↓`

Команда перемещает целиком текущую `section`:
- вверх/вниз относительно sibling’ов в том же `children` контейнере;
- переносит вместе `body` и всем поддеревом `children`.

### Indent/Outdent: `Alt+→/←`

Команды меняют вложенность секции в дереве (и как следствие её визуальный уровень).

Определения:
- `indent` делает секцию ребёнком предыдущей подходящей секции (как в outliner).
- `outdent` поднимает секцию на уровень выше (делает sibling’ом родителя).

После операции применяется нормализация outline-дерева:
- дерево всегда валидно по схеме `section(heading, body, children)`;
- глубина для стилей ограничивается 6 уровнями (визуально), но структура может быть ограничена логикой UI (не более 6 фактических уровней вложенности).

## Правила удаления/склейки (чтобы не “потеряться”)

Дополнительно (UX-guard):
- Если пользователь выделяет тело секции через `Shift+↓` и нажимает `Delete/Backspace`,
  удаляем только выделение **внутри body текущей секции** и не даём редактору “съесть границу”,
  чтобы следующая секция не превращалась в часть body предыдущей.

### Удаление заголовка

Так как “секции без заголовков” не допускаются, пустой заголовок секции не должен превращать её в “беззаголовочную секцию” в финальном результате.

Рекомендуемое правило:
- если заголовок секции пустой и пользователь продолжает удаление (Backspace в начале заголовка / удаление узла):
  - секция **сливается в предыдущую**:
    - её `body` добавляется в конец `body` предыдущей секции;
    - её `children` становятся следующими секциями после добавленного `body` (как часть children предыдущей секции).

UX для пустого заголовка при редактировании:
- Пока заголовок пустой, вместо текста заголовка показываем:
  - иконку/маркер “без названия”, и/или
  - автосгенерированное название-подсказку (например, из первых N символов body).
- При `Save`, если заголовок пустой, подставлять сгенерированный заголовок в документ (чтобы не сохранять “пустые заголовки”).
  Рекомендуемый алгоритм: взять `plain(body)` → первая непустая строка/предложение → обрезать до ~80 символов → если пусто, использовать “Без названия”.

### Склейка секций

Склейка возможна через `Backspace` в начале заголовка:
- merge with previous section (как в outliner).

При merge:
- сохраняется предсказуемость: итоговая секция остаётся “одной единицей смысла” (id предыдущей), а удалённая секция считается удалённой/влитой.

## Индексация и embeddings

### Сегментация текста

Для каждой секции `S` строим:
- `title_plain = plain(heading(S))`
- `body_plain = plain(body(S))`
- `index_text = (title_plain + "\n" + body_plain).trim()`

`children` не включаем.

### Пустые секции

- Если `index_text` пустой: секция не индексируется/embedding удаляется (как “пустой блок”).
- Если пустое тело, но есть заголовок: индексируем по заголовку.

## История секций (per-section)

Цель: дать пользователю “историю изменения именно этого блока” независимо от глобального undo.

Рекомендация:
- хранить историю не как попытку “извлечь шаги из ProseMirror history”, а как **ревизии на сохранении**:
  - при `Save` сравнить старый и новый `index_text` (или JSON) для каждой `section.id`;
  - если изменилось — записать историю `before/after` по `section.id` с timestamp и ссылкой на статью.

Практическая UX-логика:
- пользователь не нажимает “сохранить блок”;
- при уходе курсора из секции мы считаем, что секция “закоммичена” и запускаем автосохранение статьи батчем;
- сервер всё равно атомарно сохраняет весь документ/дерево, но историю пишет по изменившимся секциям.

Реализация (текущее):
- В меню статьи есть “История блока…”, которая показывает историю изменений текущей секции/блока (по `section.id`).
- Можно восстановить состояние блока “до выбранного изменения”; в outline-режиме это правит TipTap-документ и уходит в автосейв.

## Версии статьи (snapshots)

### Что такое “Версия”

- “Версия” — это **полная копия статьи** (полный snapshot содержимого и структуры) в момент времени.
- Версия используется для:
  - “зафиксировать состояние”;
  - сравнить изменения;
  - откатить статью к сохранённой версии.

### Хранение версии

На первом этапе (без коллаборации и без TipTap Cloud/Yjs):
- версию сохраняем как данные статьи целиком:
  - предпочтительно: TipTap `doc_json` (схема outline),
  - допустимо временно: материализованное дерево блоков Memus (как сейчас хранится на сервере),
  - плюс метаданные: `created_at`, `author_id`, `label` (опционально), `reason` (manual/auto).

Важно:
- Для “Версий” мы **не используем** tiptap collaboration plugins (snapshot/compare из документации TipTap), потому что они рассчитаны на Yjs/коллаборацию.
- Когда появится хранение `doc_json` на сервере, можно сделать сравнение версий на базе JSON (или через будущий tooling).

### Параллельное хранение `article_doc_json`

- На сервере хранится `articles.article_doc_json` (TipTap JSON документа), обновляется параллельно с материализацией дерева блоков.
- В “Версиях” дополнительно сохраняется `article_versions.doc_json` (TipTap JSON на момент версии), чтобы в будущем дифф/восстановление можно было делать точнее.
- Для зашифрованных статей `doc_json` не сохраняем (чтобы не хранить plaintext на сервере).

### Когда создаётся версия

- Вручную: команда пользователя “Сохранить версию”.
- Автоматически: **перед первым изменением** после долгого перерыва (≥ 12 часов с момента последнего изменения статьи).
  - То есть: как только пользователь начинает править статью после паузы, мы сначала создаём версию “как было”, затем продолжаем редактирование.

### UI (минимально)

- В меню статьи есть:
  - “Сохранить версию” (создать manual snapshot; опционально спросить `label`, можно пустой);
  - “Версии…” (открывает список версий и позволяет восстановить выбранную, а также показать отличия: версия ↔ текущая или версия ↔ версия).

Сравнение версий:
- диалог сравнения открывается почти на весь экран;
- отличающиеся фрагменты подсвечиваются цветом.

Минимальная модель ревизий:
- `section_id`
- `article_id`
- `before_plain` / `after_plain` (или `before_html` / `after_html`, или `before_json` / `after_json`)
- `saved_at`

Эта история используется для:
- UI “история блока”;
- потенциального отката конкретного блока к ревизии (вставка ревизии обратно в документ).

## Миграция с текущей модели Memus

### Стартовое состояние

Сейчас Memus хранит:
- дерево блоков статьи на сервере (каждый блок содержит HTML `text`, `collapsed`, `children`, `id`);
- индексы FTS/semantic строятся из HTML блока.

### Переход к документу TipTap

Переход рекомендуется делать постепенно:

1. Добавить хранение полного TipTap-документа на статью (например, `article_doc_json` / `article_doc_html_snapshot`).
2. Для обратной совместимости и индекса:
   - при сохранении TipTap-документа материализовать дерево секций в текущий формат блоков;
   - считать embeddings/FTS по материализованным блокам (как сейчас).
3. После стабилизации можно решить, остаётся ли материализация навсегда (для быстрого поиска/совместимости), или индексация будет считаться напрямую из TipTap JSON.

Текущее поведение (реализация):
- `GET /api/articles/{id}` возвращает `docJson` (если статья не зашифрована и он есть в БД).
- Outline-редактор при открытии:
  - сначала пытается открыть документ из `docJson`;
  - если `docJson` отсутствует — конвертирует дерево блоков в outline-doc и **один раз** сохраняет `docJson` отдельным запросом (без переписывания blocks), чтобы дальше открываться 1:1.
  - bootstrap делается через `PUT /api/articles/{id}/doc-json`.

### Конвертация “старые блоки → section doc”

При первом открытии статьи в новом редакторе:
- строим документ из текущего дерева блоков:
  - каждый блок сервера становится `section` с `id=block.id`, `collapsed=block.collapsed`;
  - заголовок блока (если есть) превращается в `sectionHeading` (визуальный уровень считается по depth);
  - если заголовок отсутствовал в старой модели — подставляется синтетический заголовок (например, “Без названия”) или автогенерация из body.
  - тело блока переносим в `body`;
  - `children` блока — в `children` секции.

## Нефункциональные требования

- Работает на мобильных браузерах (IME/selection/paste стабильны).
- Держит большие статьи (сотни/тысячи секций) без деградации UX (виртуализация обсуждается отдельно).
- Данные секций (`id`) должны быть стабильны при:
  - перемещении;
  - изменении вложенности;
  - сворачивании;
  - редактировании текста;
  - вставке/пасте контента.

## Acceptance Criteria (минимальный PoC)

1. В статье можно создавать секции: заголовок + body, включая умный Enter.
2. Любая секция сворачивается/разворачивается мышью и `Ctrl+→/←`.
3. `Alt+↑/↓` переносит секцию среди sibling’ов без потери детей.
4. `Alt+→/←` меняет вложенность секции, дерево нормализуется предсказуемо.
5. Для каждой секции вычисляется `index_text` как title+body без детей.
6. При сохранении фиксируются ревизии секций, доступные для “истории блока”.

7. Автосейв:
- изменения сохраняются автоматически и не требуют кнопки “Сохранить”;
- при уходе со статьи происходит форс-флаш;
- при ошибке сохранения создаётся локальная очередь и повтор.

8. Версии:
- можно вручную создать версию статьи;
- если статья не менялась ≥12 часов, то перед первой правкой создаётся автоверсия.
