# ТЗ: Outline-редактор на TipTap (секции по заголовкам)

## Цель

Сделать редактирование статьи как одного документа TipTap, где структура (дерево) **рождается из заголовков** и выглядит для пользователя как “структурированный текст”.

Каждая секция (заголовок + тело + дети) — **единица смысла**:
- используется как отдельный “блок” для поиска и embeddings;
- имеет устойчивый `id`;
- поддерживает сворачивание/разворачивание;
- поддерживает перемещение среди sibling’ов и смену уровня вложенности.

## Термины

- **Документ** — TipTap/ProseMirror `doc` для всей статьи.
- **Блок** — единица смысла в Memus: `heading + body + children` + `collapsed` + устойчивый `id`.
- **Секция (`section`)** — нода TipTap/ProseMirror, реализующая “блок” в документе (внутренний технический термин).
- **Единица смысла** — то, что индексируется и эмбеддится (равно секции).
- **Тело секции (`body`)** — контент секции, **не включая** дочерние секции.

## Принципы и ключевые решения

1. **Секции только с заголовками**  
   Секции без заголовков не допускаются (они визуально путают уровни).  
   “Intro” не является отдельной беззаголовочной секцией: роль intro выполняет **название статьи** (UI вне документа).

2. **Embeddings/поиск: только title + body (без детей)**  
   Для секции `S`: текст для индекса/эмбеддинга = `plain(title(S)) + "\n" + plain(body(S))`, **без** текстов дочерних секций.
   Источник истины для текста секции — `articles.article_doc_json` (outlineSection → heading/body). `blocks.text` (HTML) считается legacy и используется только как fallback.

3. **Структура хранится явно, не эвристикой**  
   В документе должна существовать явная нода `section` (а не “угадывание секций” по голым `heading/paragraph`).
   Это снижает риск “потеряться” после сложных операций (split/merge/move/paste).

3.1. **Уникальные идентификаторы секций**  
   Для `outlineSection` используется `UniqueID` (TipTap) для:
   - генерации `id` для новых секций;
   - автоматической замены `id` при paste/drag-copy (чтобы не появлялись дубликаты).

4. **Глобальный undo по статье + история по секции**  
   - Undo/redo по статье — стандартный ProseMirror `history`.
   - “История изменений именно секции” — хранится как ревизии на сохранении (см. раздел “История секций”).
   - “Сохранение секции” как UX-событие: ревизия секции фиксируется естественно при уходе курсора из секции (не отдельной кнопкой).

5. **Статья не требует явного сохранения**  
   Пользователь не должен нажимать “Сохранить/Отменить”.  
   Текст сохраняется автоматически, а “Версии” — отдельный механизм (см. ниже).

6. **TipTap грузится локально (без CDN)**  
   TipTap/ProseMirror расширения собираются в `TTree/client/outline/tiptap.bundle.js` (esbuild) и импортируются локально из `TTree/client/outline/editor.js`.
   Пересборка: `cd TTree && npm run build:tiptap`.

## UX: как это выглядит для пользователя

- Визуальная тема приложения — “Professional Slate”: единый акцент `--primary=#2563eb`, светлый фон контента `--bg-app=#f8fafc`, тёмный сайдбар на Slate (`--sidebar-bg=#0f172a`). Источник истины — CSS-переменные в `TTree/client/style.css`.
- В сайдбаре используется **одно поле** вместо двух:
  - режим **“Список”** — ввод фильтрует дерево/список статей локально (быстро, без сервера);
  - режим **“Поиск”** — ввод запускает глобальный поиск по содержимому (и показывает результаты под полем);
  - переключатель “Список/Поиск” расположен рядом с полем; `Ai`‑переключатель показывается только в режиме “Поиск”.
- Статья выглядит как структурированный текст с заголовками.
- У каждого заголовка есть контроль сворачивания/разворачивания содержимого секции (тело + дочерние секции).
- Пользователь создаёт структуру естественно: **заголовок = новая секция**.
- Внутри секции `Enter` создаёт новые абзацы **в теле**, не “новый блок”.
- В режиме outline стандартный `articleToolbar` (блочный тулбар) скрыт; на его месте показывается `outlineToolbar` с командами TipTap.
  В режиме просмотра `outlineToolbar` показывает Undo/Redo и быстрые кнопки: удалить блок (в корзину), переместить ↑/↓, сдвиг ←/→, новый блок ниже. В режиме редактирования команды сгруппированы по выпадающим меню: “Текст”, “Списки”, “Таблица” (Undo/Redo остаются отдельными кнопками).
- Двойной клик по заголовку секции в режиме просмотра: раскрывает секцию (если была свёрнута), включает режим редактирования и ставит курсор в начало тела секции.
- Статус outliner’а (“Сохраняем…”, “Сохранено …”) показывается в UI вместо `updatedAt` (в меню статьи), отдельная панель `.outline-editor__bar` не используется.
  - Вставка URL-ссылки: в одном диалоге запрашиваются и URL, и текст ссылки (текст можно оставить пустым; если было выделение — оно подставляется как текст).

## Удаление старого блочного режима (HTML blocks)

- Старый режим редактирования через `blocks.text` (HTML) выключен для обычных пользователей.
- Интерфейс статьи всегда открывается в outline‑режиме (TipTap): чтение + вход в edit‑mode по Enter/F2/dblclick.
- `blocks`/`blocks_fts` остаются как legacy‑проекция/совместимость на переходный период, но:
  - `article_links` пересчитывается из `article_doc_json` (link mark href `/article/<id>`) при сохранении outline;
  - FTS по содержимому работает через `outline_sections_fts`;
  - semantic embeddings берутся из `article_doc_json`.
  Для таблиц используем `TableKit` из `@tiptap/extension-table` (resizable columns) и команды: вставка таблицы 2×2, add/delete row/column (до/после), toggle header row/column, merge/split cell (если применимо).

## Markdown
- Официальный `@tiptap/extension-markdown` в публичном npm недоступен, используем community-пакет `tiptap-markdown` (Tiptap v3).
- Extension `Markdown` подключён в outline editor (пока без auto-transform paste).
- Команда: `editor.commands.insertMarkdown(markdown)` — конвертирует Markdown → HTML (через `editor.storage.markdown.parser`) и вставляет в текущую позицию курсора (только в edit-mode).
- Markdown-таблицы вида:
  - `| A | B |`
  - `|---|---|`
  - `| 1 | 2 |`
  при вставке (Ctrl+V) автоматически превращаются в настоящую таблицу.
- Также поддерживается “упрощённый” вариант без строки-разделителя `|---|---|`: если вставлены 1+ строк вида `| ... |` с одинаковым числом столбцов, они превращаются в таблицу без header.
- Если в существующем контенте/`doc_json` есть такая таблица текстом, при открытии outline и/или при входе в редактирование секции она мигрируется в таблицу.
  В меню “Текст” также доступны действия со ссылками: вставка URL, вставка ссылки на статью (как в rich-context-menu старого режима) и “убрать ссылку”.

### Режимы: просмотр / редактирование

Чтобы снизить риск случайных правок:
- По умолчанию секции находятся в режиме **просмотра**: можно перемещать курсор, выделять и копировать текст, но любые изменения документа (ввод, удаление, вставка, drag&drop) блокируются.
- `Enter` или `F2` включает режим **редактирования** для текущей секции (редактируются только её `heading` и `body`, без детей).
- `dblclick` по секции также включает режим редактирования для этой секции.
- `Esc` — выход из режима редактирования обратно в просмотр.
- При уходе курсора в другую секцию режим редактирования автоматически выключается.
- При выходе из режима редактирования (`Esc`) автозаголовок и proofreading запускаются так же, как при “уходе” в другую секцию (если заголовок пустой / были изменения).
- Undo/Redo должны работать в обоих режимах (view/edit), т.к. это безопасная обратимая операция.
- В режиме просмотра клики по ссылкам должны открывать их (вкладка/переход), в режиме редактирования клик работает как обычная установка курсора.
- Склейка секций через `Backspace` на границе (в начале заголовка) доступна **только в режиме редактирования** и защищена от “зажатой клавиши”:
  - первое нажатие (`repeat=false`) — только тост “Нажмите ещё раз, чтобы объединить блоки”, без склейки;
  - второе нажатие в течение ~1.2 секунды — выполняет склейку;
  - автоповтор (`repeat=true`) игнорируется и склейку не запускает.
  - аналогично для `Delete` на границе (в конце `body`) при объединении с нижним sibling.
  - при склейке заголовок “нижней” секции не теряется: он переносится в `body` секции-приёмника отдельным абзацем, затем добавляется `body`.

## Сохранение (автосейв)

### Принцип

- Сохранение статьи происходит **автоматически** (debounce) и не требует действий пользователя.
- Единственная “явная” сущность, которую пользователь может сохранять руками — это **Версия** (snapshot).

### Триггеры автосейва

- Любое изменение документа: debounce ~1–2 секунды.
- Уход со статьи / переключение на другую статью / `blur` окна: форс-флаш очереди (без диалогов).

### Гарантии при сбоях

- Если сеть/сервер недоступны: изменения складываются в простую **локальную очередь** (пока `localStorage`).
- При восстановлении соединения или следующем удобном случае очередь “догоняется”.
- В будущем (offline-first) очередь переносится в IndexedDB, но в этом ТЗ — “как проще”.

### UI (минимально)

- Нет кнопок “Сохранить” и “Отменить” в редакторе статьи.
- Можно показывать неблокирующий статус: “Сохраняется… / Сохранено / Ошибка, повторим”.

## Горячие клавиши (обязательные)

- `Alt+↑/↓`: переместить текущую секцию среди sibling’ов (вверх/вниз).
- `Alt+→/←`: indent/outdent секции (смена уровня вложенности в дереве) + нормализация дерева.
- `Ctrl+→/←`: collapse/expand текущей секции.
- `Ctrl+↑`: схлопнуть **родительскую** секцию (и всех детей внутри неё).
- `Ctrl+↓`: развернуть **текущую** секцию (и всех её детей).

Примечания:
- Если текущая секция свернута — `Ctrl+→` разворачивает, `Ctrl+←` сворачивает (направления можно инвертировать, но должны быть консистентны).
- Для macOS желательно дополнить альтернативами (`Meta`/`Alt`) позже, но в этом ТЗ фиксируем базовые комбинации.

## “Умный Enter” (создание новой секции без отдельной команды)

### Поведение

Внутри `body` текущей секции:
- `Enter` обычно создаёт новый абзац (как в обычном редакторе).
- Если курсор находится в **пустом последнем абзаце body** и пользователь нажимает `Enter` ещё раз (то есть это **третье Enter подряд** в конце секции):
  - вместо добавления ещё одного пустого абзаца создаётся **новая секция-сиблинг** после текущей;
  - новая секция создаётся на той же глубине (sibling текущей секции) и сразу переводится в режим редактирования (курсор в её заголовке).

### Условия срабатывания (детерминированные)

Срабатывание допускается только когда выполняются все условия:
- курсор находится внутри `body` ноды `section`;
- текущий параграф пустой (после нормализации: нет видимого текста/медиа);
- параграф является последним блоком внутри `body`;
- на момент обработки уже есть состояние “предыдущий Enter был в этом же месте” (anti-accidental).

### Визуальная подсказка

Новая секция создаётся с пустым заголовком, но UI должен показывать плейсхолдер заголовка (например, “Заголовок…”), чтобы пользователь не воспринимал это как “абзац без заголовка”.

## Split секции (разбиение)

- `Ctrl+Enter`: разбиение секции в позиции курсора.
  - Если курсор в `body`: создаётся новая секция ниже, в неё переносится “хвост” body после курсора и **все children** исходной секции.
  - Если курсор в `heading`: заголовок делится на две секции, при этом body+children переносятся в новую (вторую) секцию.

## Списки (UX)

- `Enter` внутри `li` по умолчанию создаёт новый `li` (поведение ProseMirror).
- Чтобы превратить новый `li` в “второй абзац предыдущего пункта”, нажмите `Backspace` в начале `li`:
  содержимое текущего `li` будет перенесено как **новый абзац** в конец предыдущего `li` (без склейки в одну строку).

## Модель документа (ProseMirror/TipTap)

## Изображения (uploads + resize)

- В outline режиме вставка/дроп изображения должна работать как в старом режиме:
  - файл загружается на сервер через `POST /api/uploads` (сервер ресайзит до max width 1920 и конвертирует в WebP);
  - в документ вставляется картинка с `src=/uploads/...`;
  - ширина картинки вручную меняется “хэндлом” (drag вправо/влево) и сохраняется в документе.
- При вставке картинка обрамляется пробелами (слева/справа), чтобы можно было сразу вводить текст до/после изображения.
- В текущей реализации вставляем по два пробела слева/справа (чтобы точно было место под ввод).
- UI/стили ресайза используются те же, что и в старом режиме (`.resizable-image`, `.resizable-image__handle`).
- В режиме просмотра клик по картинке открывает увеличенный просмотр (как в старом режиме).

### Нода `section`

`section` — блочная нода, содержащая:
- `heading` (обязательный, ровно один);
- `body` (контейнер для контента секции, без заголовков);
- `children` (контейнер для вложенных `section`).

Рекомендуемая форма (схематично):

- `doc: section+`
- `section: heading body children`
- `heading: sectionHeading(id=sectionId) inline*`
- `body: block*` (paragraph/list/table/image/etc; **без** heading/section)
- `children: section*`

### Атрибуты секции

`section.attrs`:
- `id: string` — устойчивый идентификатор секции (единица смысла; соответствует `block_id` на сервере).
- `collapsed: boolean` — состояние свёрнутости.

Примечание про “уровень заголовка”:
- Пользователь **не выбирает** стиль/уровень заголовка (h1/h2/…).
- Визуальный “уровень” секции считается **на лету** по глубине вложенности (depth) при отрисовке.
- Для стилизации используем максимум 6 уровней (clamp `1..6`), больше не требуется.

### Инварианты (обязательная нормализация)

Документ должен удовлетворять:
- `section` всегда содержит `heading` (не пустую ноду, но текст заголовка может быть пустым во время редактирования).
- `section` всегда содержит `heading` (узел обязателен; текст заголовка может быть пустым во время редактирования).
- Внутри `body` **не может** быть `heading` или `section`.
- Дочерние секции живут только внутри `children`.
- Порядок: `heading` всегда над `body`, а `children` всегда после `body`.

Нужен нормализующий плагин, который после транзакций чинит нарушения (paste/drop/join/удаления):
- если `heading` попал в `body`, он должен быть преобразован в новую `section` (с корректным `id`) в `children` или sibling в зависимости от контекста;
- если `section` нарушила структуру, приводим к `section(heading, body, children)` минимальными правками.

## Сворачивание секций

- Сворачивание работает на уровне `section.attrs.collapsed`.
- В свернутом состоянии:
  - заголовок секции видим;
  - `body + children` скрыты (визуально), но остаются в документе (не удаляются).
- Кнопка/гаттер у заголовка должна менять `collapsed`.
- Горячие клавиши `Ctrl+→/←` должны менять `collapsed` у текущей секции.

## Перемещение и изменение вложенности

### Перемещение среди sibling’ов: `Alt+↑/↓`

Команда перемещает целиком текущую `section`:
- вверх/вниз относительно sibling’ов в том же `children` контейнере;
- переносит вместе `body` и всем поддеревом `children`.

### Indent/Outdent: `Alt+→/←`

Команды меняют вложенность секции в дереве (и как следствие её визуальный уровень).

Определения:
- `indent` делает секцию ребёнком предыдущей подходящей секции (как в outliner).
- `outdent` поднимает секцию на уровень выше (делает sibling’ом родителя).

UX-правило видимости:
- если при `indent` новый родитель был свёрнут, он автоматически разворачивается, чтобы перенесённая секция оставалась видимой.

После операции применяется нормализация outline-дерева:
- дерево всегда валидно по схеме `section(heading, body, children)`;
- глубина для стилей ограничивается 6 уровнями (визуально), но структура может быть ограничена логикой UI (не более 6 фактических уровней вложенности).

## Правила удаления/склейки (чтобы не “потеряться”)

Дополнительно (UX-guard):
- Если пользователь выделяет тело секции через `Shift+↓` и нажимает `Delete/Backspace`,
  удаляем только выделение **внутри body текущей секции** и не даём редактору “съесть границу”,
  чтобы следующая секция не превращалась в часть body предыдущей.

### Удаление заголовка

Так как “секции без заголовков” не допускаются, пустой заголовок секции не должен превращать её в “беззаголовочную секцию” в финальном результате.

Рекомендуемое правило:
- если заголовок секции пустой и пользователь продолжает удаление (Backspace в начале заголовка / удаление узла):
  - секция **сливается в предыдущую**:
    - её `body` добавляется в конец `body` предыдущей секции;
    - её `children` становятся следующими секциями после добавленного `body` (как часть children предыдущей секции).

UX для пустого заголовка при редактировании:
- Пока заголовок пустой, вместо текста заголовка показываем:
  - иконку/маркер “без названия”, и/или
  - автосгенерированное название-подсказку (например, из первых N символов body).
- При уходе курсора из секции, если заголовок всё ещё пустой, можно автоматически предложить/поставить заголовок,
  сгенерированный дешёвой моделью OpenAI по `plain(body)` (ограничение 200 символов, русский).
  Для зашифрованных статей эта генерация отключена (не отправляем plaintext наружу).

### Авто-исправление ошибок (proofread) при выходе из секции

Если пользователь **покинул секцию** (курсор ушёл в другую секцию) и при этом **в секции были изменения**:
- отправляем `body` текущей секции (HTML) в `gpt-4o-mini` на “исправление ошибок”;
- применяем ответ обратно в `body` секции;
- ничего не делаем для зашифрованных статей (не отправляем plaintext/HTML наружу).

Ключевые ограничения промпта (обязательны):
- не добавлять новые слова, не удалять существующие, не менять порядок слов;
- можно удалять только повторы подряд идущих одинаковых слов;
- не нарушать существующую HTML-разметку;
- исправлять орфографию/пунктуацию/заглавные/повторы/согласование (только заменами существующих слов).
- При `Save`, если заголовок пустой, подставлять сгенерированный заголовок в документ (чтобы не сохранять “пустые заголовки”).
  Рекомендуемый алгоритм: взять `plain(body)` → первая непустая строка/предложение → обрезать до ~80 символов → если пусто, использовать “Без названия”.

### Склейка секций

Склейка возможна через `Backspace` в начале заголовка:
- merge with previous section (как в outliner).

Если секция — первый child (предыдущего sibling нет), то `Backspace` в начале заголовка:
- удаляет секцию,
- переносит её заголовок+body в конец `body` родителя,
- а её children поднимает на уровень родителя (в начало children родителя).

При merge:
- сохраняется предсказуемость: итоговая секция остаётся “одной единицей смысла” (id предыдущей), а удалённая секция считается удалённой/влитой.

## Индексация и embeddings

### Сегментация текста

Для каждой секции `S` строим:
- `title_plain = plain(heading(S))`
- `body_plain = plain(body(S))`
- `index_text = (title_plain + "\n" + body_plain).trim()`

`children` не включаем.

### Пустые секции

- Если `index_text` пустой: секция не индексируется/embedding удаляется (как “пустой блок”).
- Если пустое тело, но есть заголовок: индексируем по заголовку.

## История секций (per-section)

Цель: дать пользователю “историю изменения именно этого блока” независимо от глобального undo.

Рекомендация:
- хранить историю не как попытку “извлечь шаги из ProseMirror history”, а как **ревизии на сохранении**:
  - при `Save` сравнить старый и новый `index_text` (или JSON) для каждой `section.id`;
  - если изменилось — записать историю `before/after` по `section.id` с timestamp и ссылкой на статью.

Практическая UX-логика:
- пользователь не нажимает “сохранить блок”;
- при уходе курсора из секции мы считаем, что секция “закоммичена” и запускаем автосохранение статьи батчем;
- сервер всё равно атомарно сохраняет весь документ/дерево, но историю пишет по изменившимся секциям.

Реализация (текущее):
- В меню статьи есть “История блока…”, которая показывает историю изменений текущей секции/блока (по `section.id`).
- История пишется на сервере при сохранении `article_doc_json` (ревизии `before/after` по `section.id`).
- Восстановление восстанавливает состояние “после выбранного изменения” и в outline-режиме правит TipTap-документ (только `heading/body`, дети сохраняются), затем уходит в автосейв.
- Вся старая история HTML-блоков очищается (одноразовая миграция в `schema.py`, ключ `schema_meta.purged_legacy_block_history_v1`).

## Вложения (Yandex Disk) в outline

- Drop/Paste не‑картинок внутри секции в режиме редактирования загружает файл как вложение на Яндекс.Диск (как в старом режиме) и вставляет ссылку в текст.
- В view-mode дроп файлов не должен уводить пользователя со страницы (есть глобальный guard на drag&drop).

## Версии статьи (snapshots)

### Что такое “Версия”

- “Версия” — это **полная копия статьи** (полный snapshot содержимого и структуры) в момент времени.
- Версия используется для:
  - “зафиксировать состояние”;
  - сравнить изменения;
  - откатить статью к сохранённой версии.

### Хранение версии

На первом этапе (без коллаборации и без TipTap Cloud/Yjs):
- версию сохраняем как данные статьи целиком:
  - предпочтительно: TipTap `doc_json` (схема outline),
  - допустимо временно: материализованное дерево блоков Memus (как сейчас хранится на сервере),
  - плюс метаданные: `created_at`, `author_id`, `label` (опционально), `reason` (manual/auto).

Важно:
- Для “Версий” мы **не используем** tiptap collaboration plugins (snapshot/compare из документации TipTap), потому что они рассчитаны на Yjs/коллаборацию.
- Когда появится хранение `doc_json` на сервере, можно сделать сравнение версий на базе JSON (или через будущий tooling).

### Параллельное хранение `article_doc_json`

- На сервере хранится `articles.article_doc_json` (TipTap JSON документа), обновляется параллельно с материализацией дерева блоков.
- В “Версиях” дополнительно сохраняется `article_versions.doc_json` (TipTap JSON на момент версии), чтобы в будущем дифф/восстановление можно было делать точнее.
- Для зашифрованных статей `doc_json` не сохраняем (чтобы не хранить plaintext на сервере).

### Миграция всех статей в `doc_json`

- Скрипт конвертирует существующие `blocks.text` (HTML) в `articles.article_doc_json` для всех статей, у которых `doc_json` ещё не заполнен.
- Команда:
  - `cd TTree && python3 -m servpy.app.migrate_doc_json_from_blocks`
  - Опционально можно передать `limit` (число статей): `python3 -m servpy.app.migrate_doc_json_from_blocks 50`
- Дополнительно:
  - `--dry-run` — прогнать конвертацию без записи в БД;
  - `--force` — перезаписать `article_doc_json` даже если он уже заполнен (опасно; использовать только если точно уверены, что `blocks` — источник истины).
- Требования: установлен `node` и выполнен `npm install` в `TTree/` (конвертер использует локальные зависимости TipTap и `happy-dom`).
- Если в будущем появятся зашифрованные статьи, их мигрировать нельзя без расшифровки.

### Семантические embeddings: источник текста

- Семантический индекс (`block_embeddings`) строится из `articles.article_doc_json`, по секциям `outlineSection.attrs.id`.
- Текст секции для embeddings = `plain(heading) + "\n" + plain(body)` (без детей).
- `blocks.text` (HTML) остаётся только для legacy-рендера/совместимости и используется как fallback, если `doc_json` недоступен.

### FTS (обычный поиск): `outline_sections_fts`

- Обычный поиск по содержимому блоков работает через таблицу `outline_sections_fts`.
- Индексируемая единица = секция (`outlineSection.attrs.id`), то есть тот же `blockId`.
- Храним:
  - `text` — plain-text секции (heading+body, без детей),
  - `lemma` и `normalized_text` (как и в старом FTS),
  - `search_vector` (tsvector) + GIN индекс.
- Переиндексация: `python3 -m servpy.app.reindex_fts` (пересобирает `articles_fts`, `blocks_fts` и `outline_sections_fts`).

### `article_links` (внутренние ссылки)

- Внутренние ссылки на статьи извлекаются из `article_doc_json`:
  - TipTap mark `link` с `href="/article/<uuid>"` (или абсолютный URL `https://memus.pro/article/<uuid>`).
- Сохраняем в `article_links(from_id, block_id=section_id, to_id, kind='internal')`.

### Когда создаётся версия

- Вручную: команда пользователя “Сохранить версию”.
- Автоматически: **перед первым изменением** после долгого перерыва (≥ 12 часов с момента последнего изменения статьи).
  - То есть: как только пользователь начинает править статью после паузы, мы сначала создаём версию “как было”, затем продолжаем редактирование.

### UI (минимально)

- В меню статьи есть:
  - “Сохранить версию” (создать manual snapshot; опционально спросить `label`, можно пустой);
  - “Версии…” (открывает список версий и позволяет восстановить выбранную, а также показать отличия: версия ↔ текущая или версия ↔ версия).

Сравнение версий:
- диалог сравнения открывается почти на весь экран;
- диалог сравнения всегда в светлой теме (вне зависимости от общей темы интерфейса);
- отличающиеся фрагменты подсвечиваются цветом.

Минимальная модель ревизий:
- `section_id`
- `article_id`
- `before_plain` / `after_plain` (или `before_html` / `after_html`, или `before_json` / `after_json`)
- `saved_at`

Эта история используется для:
- UI “история блока”;
- потенциального отката конкретного блока к ревизии (вставка ревизии обратно в документ).

## Миграция с текущей модели Memus

### Стартовое состояние

Сейчас Memus хранит:
- дерево блоков статьи на сервере (каждый блок содержит HTML `text`, `collapsed`, `children`, `id`);
- FTS-индекс по секциям строится из `articles.article_doc_json` (outlineSection: heading+body, без детей) и хранится в `outline_sections_fts`.
- semantic embeddings строятся из `articles.article_doc_json` (см. раздел выше).

### Переход к документу TipTap

Переход рекомендуется делать постепенно:

1. Добавить хранение полного TipTap-документа на статью (например, `article_doc_json` / `article_doc_html_snapshot`).
2. Для обратной совместимости и индекса:
   - при сохранении TipTap-документа материализовать дерево секций в текущий формат блоков;
   - **не** привязывать индексы к HTML: считать embeddings/FTS из `article_doc_json` и держать отдельную индекс‑таблицу по секциям.
3. После стабилизации можно решить, остаётся ли материализация навсегда (для быстрого поиска/совместимости), или индексация будет считаться напрямую из TipTap JSON.

Текущее поведение (реализация):
- `GET /api/articles/{id}` возвращает `docJson` (если статья не зашифрована и он есть в БД).
- Outline-редактор при открытии:
  - сначала пытается открыть документ из `docJson`;
  - если `docJson` отсутствует — конвертирует дерево блоков в outline-doc и **один раз** сохраняет `docJson` отдельным запросом (без переписывания blocks), чтобы дальше открываться 1:1.
  - bootstrap делается через `PUT /api/articles/{id}/doc-json`.

Рендер/экспорт/публичный рендер (doc_json-first):
- Экспорт статьи в HTML делается на сервере из `article_doc_json`: `GET /api/articles/{id}/export/html` (HTML самодостаточный: `/uploads/...` инлайнится в `data:`).
- Экспорт всех статей в ZIP (`/api/export/html-zip`) использует тот же рендерер и тоже основан на `article_doc_json`.
- Публичная страница (`/p/<slug>`) использует **те же клиентские скрипты, что и outliner** (`/outline/editor.js`), но включает строгий read-only режим (без входа в edit-mode, без автосейва).
- В публичном просмотре не показываем верхнюю панель outliner’а (`.outline-editor__bar`).
- Для 1:1 визуала публичная страница монтирует outliner в контейнер с классом `.outline-editor` (там объявлены CSS-переменные для рамок/цветов секций).
- Перед монтированием outliner сервер переписывает внутренние ссылки в `doc_json`: `/article/<id> → /p/<slug>`, а если статья не опубликована — `href="#"` и `rel+="unpublished"` (клик показывает алерт).
- Экспорт/ZIP остаются server-side и продолжают рендериться из `article_doc_json` (Node renderer → Python fallback при необходимости).

Kill-switch для проверки отказа от `blocks`:
- Если установить `SERVPY_BLOCKS_KILL_SWITCH=1`, сервер будет падать на любой runtime SQL-запрос, который обращается к таблицам `blocks`/`blocks_fts` (DDL в `schema.py` разрешён).

### Конвертация “старые блоки → section doc”

При первом открытии статьи в новом редакторе:
- строим документ из текущего дерева блоков:
  - каждый блок сервера становится `section` с `id=block.id`, `collapsed=block.collapsed`;
  - заголовок блока (если есть) превращается в `sectionHeading` (визуальный уровень считается по depth);
  - если заголовок отсутствовал в старой модели — подставляется синтетический заголовок (например, “Без названия”) или автогенерация из body.
  - тело блока переносим в `body`;
  - `children` блока — в `children` секции.

## Нефункциональные требования

- Работает на мобильных браузерах (IME/selection/paste стабильны).
- Держит большие статьи (сотни/тысячи секций) без деградации UX (виртуализация обсуждается отдельно).
- Данные секций (`id`) должны быть стабильны при:
  - перемещении;
  - изменении вложенности;
  - сворачивании;
  - редактировании текста;
  - вставке/пасте контента.

## Acceptance Criteria (минимальный PoC)

1. В статье можно создавать секции: заголовок + body, включая умный Enter.
2. Любая секция сворачивается/разворачивается мышью и `Ctrl+→/←`.
3. `Alt+↑/↓` переносит секцию среди sibling’ов без потери детей.
4. `Alt+→/←` меняет вложенность секции, дерево нормализуется предсказуемо.
5. Для каждой секции вычисляется `index_text` как title+body без детей.
6. При сохранении фиксируются ревизии секций, доступные для “истории блока”.

7. Автосейв:
- изменения сохраняются автоматически и не требуют кнопки “Сохранить”;
- при уходе со статьи происходит форс-флаш;
- при ошибке сохранения создаётся локальная очередь и повтор.

8. Версии:
- можно вручную создать версию статьи;
- если статья не менялась ≥12 часов, то перед первой правкой создаётся автоверсия.
